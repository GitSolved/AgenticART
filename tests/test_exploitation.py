"""
Tests for the Exploitation Module

Run with: pytest tests/test_exploitation.py -v
"""

import os
import sys
from unittest.mock import MagicMock, patch

import pytest

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from conftest import MockADB

from core.exploitation.exploit_runner import ExecutionMode, ExploitRunner
from core.exploitation.docker_executor import DockerConfig, DockerExecutor
from core.exploitation.techniques.adb_exploits import ADBExploiter
from core.exploitation.techniques.bootloader_unlock import BootloaderUnlocker, DeviceManufacturer
from core.exploitation.techniques.kernel_exploits import KernelExploiter, KernelExploitType


class TestExploitRunner:
    """Tests for Exploit Runner."""

    def test_dry_run_mode(self, tmp_path):
        """Test dry run execution mode."""
        runner = ExploitRunner(mode=ExecutionMode.DRY_RUN)

        # Create a test script
        script = tmp_path / "test.py"
        script.write_text("print('hello')")

        result = runner.execute(str(script))

        assert result.mode == ExecutionMode.DRY_RUN
        assert "[DRY RUN]" in result.stdout
        assert result.success

    def test_dry_run_validation(self, tmp_path):
        """Test that dry run validates syntax."""
        runner = ExploitRunner(mode=ExecutionMode.DRY_RUN)

        # Create a script with syntax error
        script = tmp_path / "bad.py"
        script.write_text("def broken(\n")  # Missing closing paren

        result = runner.execute(str(script))

        assert not result.success
        assert "Syntax error" in result.stderr

    def test_command_execution_dry_run(self):
        """Test command execution in dry run mode."""
        runner = ExploitRunner(mode=ExecutionMode.DRY_RUN)

        result = runner.execute_command("adb shell id")

        assert result.success
        assert "[DRY RUN]" in result.stdout


class TestKernelExploiter:
    """Tests for Kernel Exploiter."""

    def test_kernel_version_parsing(self):
        """Test kernel version parsing."""
        responses = {
            "uname -r": "4.14.186-perf+",
            "uname -m": "aarch64",
            "prop:ro.build.version.release": "10",
            "prop:ro.hardware": "qcom",
        }
        mock_adb = MockADB(responses)
        exploiter = KernelExploiter(mock_adb)

        info = exploiter.get_kernel_info()

        assert info.major == 4
        assert info.minor == 14
        assert info.patch == 186

    def test_dirty_cow_vulnerability_detection(self):
        """Test Dirty COW vulnerability detection on old kernel."""
        responses = {
            "uname -r": "3.18.71-g1234567",  # Old kernel
            "uname -m": "aarch64",
            "prop:ro.build.version.release": "7.0",
            "prop:ro.hardware": "qcom",
        }
        mock_adb = MockADB(responses)
        exploiter = KernelExploiter(mock_adb)

        info = exploiter.get_kernel_info()

        assert KernelExploitType.DIRTY_COW in info.vulnerable_to

    def test_dirty_pipe_detection(self):
        """Test Dirty Pipe detection on vulnerable kernel."""
        responses = {
            "uname -r": "5.10.43-android12",
            "uname -m": "aarch64",
            "prop:ro.build.version.release": "12",
            "prop:ro.hardware": "qcom",
        }
        mock_adb = MockADB(responses)
        exploiter = KernelExploiter(mock_adb)

        info = exploiter.get_kernel_info()

        assert KernelExploitType.DIRTY_PIPE in info.vulnerable_to

    def test_mediatek_detection(self):
        """Test MediaTek SoC detection."""
        responses = {
            "uname -r": "4.14.141",
            "uname -m": "aarch64",
            "prop:ro.build.version.release": "10",
            "prop:ro.hardware": "mt6789",
        }
        mock_adb = MockADB(responses)
        exploiter = KernelExploiter(mock_adb)

        info = exploiter.get_kernel_info()

        assert KernelExploitType.MEDIATEK_SU in info.vulnerable_to


class TestADBExploiter:
    """Tests for ADB Exploiter."""

    def test_debuggable_app_detection(self):
        """Test detection of debuggable applications."""
        responses = {
            "pm list packages -3 | cut -d: -f2": "com.app1\ncom.app2\ncom.app3",
            "run-as com.app1 id": "uid=10001(u0_a1)",  # Debuggable
            "run-as com.app2 id": "run-as: Package 'com.app2' is not debuggable",
            "run-as com.app3 id": "uid=10003(u0_a3)",  # Debuggable
        }
        mock_adb = MockADB(responses)
        exploiter = ADBExploiter(mock_adb)

        debuggable = exploiter.find_debuggable_apps()

        assert "com.app1" in debuggable
        assert "com.app3" in debuggable
        assert "com.app2" not in debuggable

    def test_adb_root_check(self):
        """Test ADB root availability check."""
        # Test userdebug build
        responses = {
            "prop:ro.build.type": "userdebug",
            "prop:ro.debuggable": "1",
        }
        mock_adb = MockADB(responses)
        exploiter = ADBExploiter(mock_adb)

        # Would need to mock the execute method for full test
        assert exploiter is not None


class TestBootloaderUnlocker:
    """Tests for Bootloader Unlocker."""

    def test_manufacturer_detection_google(self):
        """Test Google device detection."""
        responses = {
            "prop:ro.product.manufacturer": "Google",
            "prop:ro.product.brand": "google",
        }
        mock_adb = MockADB(responses)
        unlocker = BootloaderUnlocker(mock_adb)

        manufacturer = unlocker.detect_manufacturer()

        assert manufacturer == DeviceManufacturer.GOOGLE

    def test_manufacturer_detection_samsung(self):
        """Test Samsung device detection."""
        responses = {
            "prop:ro.product.manufacturer": "samsung",
            "prop:ro.product.brand": "samsung",
        }
        mock_adb = MockADB(responses)
        unlocker = BootloaderUnlocker(mock_adb)

        manufacturer = unlocker.detect_manufacturer()

        assert manufacturer == DeviceManufacturer.SAMSUNG

    def test_bootloader_status_unlocked(self):
        """Test unlocked bootloader detection."""
        responses = {
            "prop:ro.product.manufacturer": "Google",
            "prop:ro.product.brand": "google",
            "prop:ro.product.model": "Pixel 7",
            "prop:ro.boot.flash.locked": "0",
            "prop:ro.boot.verifiedbootstate": "orange",
            "prop:ro.boot.secureboot": "0",
            "prop:sys.oem_unlock_allowed": "1",
        }
        mock_adb = MockADB(responses)
        unlocker = BootloaderUnlocker(mock_adb)

        status = unlocker.get_bootloader_status()

        assert status.is_unlocked
        assert status.manufacturer == DeviceManufacturer.GOOGLE

    def test_unlock_steps_for_google(self):
        """Test that Google devices get correct unlock steps."""
        responses = {
            "prop:ro.product.manufacturer": "Google",
            "prop:ro.product.brand": "google",
            "prop:ro.product.model": "Pixel 7",
            "prop:ro.boot.flash.locked": "1",
            "prop:ro.boot.verifiedbootstate": "green",
            "prop:sys.oem_unlock_allowed": "1",
        }
        mock_adb = MockADB(responses)
        unlocker = BootloaderUnlocker(mock_adb)

        status = unlocker.get_bootloader_status()

        assert not status.is_unlocked
        assert "fastboot" in status.unlock_steps[3].lower()


class TestDockerExecutor:
    """Tests for Docker-based sandbox execution."""

    @pytest.fixture
    def docker_config(self):
        """Create test Docker configuration."""
        return DockerConfig(
            image_name="test-sandbox:latest",
            network="test-network",
            memory_limit="256m",
            emulator_device="localhost:5555",
        )

    @patch("core.exploitation.docker_executor.subprocess.run")
    def test_docker_execution_success(self, mock_run, docker_config, tmp_path):
        """Test successful script execution in Docker container."""
        mock_run.return_value = MagicMock(
            returncode=0,
            stdout="script output",
            stderr="",
        )

        executor = DockerExecutor(config=docker_config, timeout=60)
        script = tmp_path / "test.py"
        script.write_text("print('hello')")

        result = executor.execute(str(script))

        assert result.success
        assert result.stdout == "script output"
        assert result.return_code == 0

    @patch("core.exploitation.docker_executor.subprocess.run")
    def test_docker_execution_failure(self, mock_run, docker_config, tmp_path):
        """Test failed script execution."""
        mock_run.return_value = MagicMock(
            returncode=1,
            stdout="",
            stderr="Error: command failed",
        )

        executor = DockerExecutor(config=docker_config, timeout=60)
        script = tmp_path / "test.py"
        script.write_text("raise Exception('fail')")

        result = executor.execute(str(script))

        assert not result.success
        assert result.return_code == 1

    @patch("core.exploitation.docker_executor.subprocess.run")
    def test_docker_timeout_handling(self, mock_run, docker_config, tmp_path):
        """Test container timeout handling."""
        from subprocess import TimeoutExpired
        mock_run.side_effect = TimeoutExpired(cmd="docker", timeout=60)

        executor = DockerExecutor(config=docker_config, timeout=60)
        script = tmp_path / "test.py"
        script.write_text("import time; time.sleep(1000)")

        result = executor.execute(str(script))

        assert not result.success
        assert "timed out" in result.stderr.lower()

    @patch("core.exploitation.docker_executor.subprocess.run")
    def test_docker_security_constraints_in_command(self, mock_run, docker_config, tmp_path):
        """Verify security options are included in docker command."""
        mock_run.return_value = MagicMock(returncode=0, stdout="", stderr="")

        executor = DockerExecutor(config=docker_config, timeout=60)
        script = tmp_path / "test.py"
        script.write_text("print('test')")

        executor.execute(str(script))

        # Get the command that was passed to subprocess.run
        call_args = mock_run.call_args[0][0]
        cmd_str = " ".join(call_args)

        # Verify security constraints
        assert "--cap-drop" in cmd_str
        assert "ALL" in cmd_str
        assert "--cap-add" in cmd_str
        assert "NET_RAW" in cmd_str
        assert "--security-opt" in cmd_str
        assert "--read-only" in cmd_str
        assert "--user" in cmd_str
        assert "pentester" in cmd_str

    @patch("core.exploitation.docker_executor.subprocess.run")
    def test_docker_runner_integration(self, mock_run, tmp_path):
        """Test ExploitRunner with DOCKER mode."""
        mock_run.return_value = MagicMock(
            returncode=0,
            stdout="docker output",
            stderr="",
        )

        runner = ExploitRunner(mode=ExecutionMode.DOCKER, timeout=60)
        script = tmp_path / "test.py"
        script.write_text("print('hello')")

        result = runner.execute(str(script))

        assert result.mode == ExecutionMode.DOCKER
        assert result.success
        assert result.stdout == "docker output"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
