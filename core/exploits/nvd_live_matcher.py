"""
Live NVD API CVE Matcher for Android 14

Queries the NVD API in real-time to find CVEs that:
1. Affect the target Android version
2. Were published AFTER the device's security patch date
3. Have high exploitability scores

For authorized security testing only.
"""

import logging
import os
import re
from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional

import requests

from core.exploits.poc_fetcher import PoCFetcher  # noqa: F401 (re-exported via __init__.py)

logger = logging.getLogger(__name__)


@dataclass
class LiveCVE:
    """CVE from live NVD API query."""
    cve_id: str
    published: str
    cvss_score: float
    severity: str
    description: str
    attack_vector: str = "NETWORK"
    exploit_maturity: str = "UNPROVEN"
    affected_versions: list = field(default_factory=list)
    references: list = field(default_factory=list)
    cwe_ids: list = field(default_factory=list)


class NVDLiveMatcher:
    """
    Live NVD API matcher for finding unpatched CVEs.

    Usage:
        matcher = NVDLiveMatcher(api_key="your_nvd_api_key")
        cves = matcher.find_unpatched_cves(
            android_version="14",
            security_patch="2023-11-01"
        )
    """

    BASE_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0"

    def __init__(self, api_key: Optional[str] = None):
        self.api_key = api_key or os.getenv("NVD_API_KEY")
        if not self.api_key:
            logger.warning("No NVD API key - rate limits will apply")

        self.session = requests.Session()
        if self.api_key:
            self.session.headers["apiKey"] = self.api_key

    def find_unpatched_cves(
        self,
        android_version: str,
        security_patch: str,
        min_cvss: float = 7.0,
        max_results: int = 50
    ) -> list:
        """
        Find CVEs that are potentially unpatched on the target device.

        Args:
            android_version: Target Android version (e.g., "14")
            security_patch: Security patch date (e.g., "2023-11-01")
            min_cvss: Minimum CVSS score to consider
            max_results: Maximum CVEs to return

        Returns:
            List of LiveCVE objects sorted by exploitability
        """
        patch_date = datetime.strptime(security_patch, "%Y-%m-%d")
        all_cves: list[LiveCVE] = []

        # Search strategies for Android vulnerabilities
        search_queries = [
            f"Android {android_version}",
            "Android kernel privilege escalation",
            "Android binder",
            "Android system_server",
            "Android mediaserver",
            "Android bluetooth",
            "Android NFC",
        ]

        for query in search_queries:
            cves = self._query_nvd(query, max_results=100)

            for cve_data in cves:
                cve = self._parse_cve(cve_data)

                if cve is None:
                    continue

                # Filter: Must be high severity
                if cve.cvss_score < min_cvss:
                    continue

                # Filter: Published AFTER patch date (potentially unpatched)
                try:
                    pub_date = datetime.strptime(cve.published[:10], "%Y-%m-%d")
                    if pub_date <= patch_date:
                        continue
                except ValueError:
                    continue

                # Check if already added
                if any(c.cve_id == cve.cve_id for c in all_cves):
                    continue

                all_cves.append(cve)

        # Sort by CVSS score and exploitability
        all_cves.sort(key=lambda c: (
            c.exploit_maturity == "POC",
            c.attack_vector == "LOCAL",
            c.cvss_score
        ), reverse=True)

        logger.info(f"Found {len(all_cves)} unpatched CVEs for Android {android_version}")
        return all_cves[:max_results]

    def find_kernel_exploits(self, kernel_version: str) -> list[LiveCVE]:
        """Find CVEs targeting the specific kernel version."""
        cves: list[LiveCVE] = []

        # Parse kernel version (e.g., "5.10.160-android14-4-something")
        major_minor = re.match(r"(\d+\.\d+)", kernel_version)
        if major_minor:
            kernel_search = major_minor.group(1)
        else:
            kernel_search = kernel_version[:10]

        queries = [
            f"Linux kernel {kernel_search}",
            "Linux kernel privilege escalation",
            "Linux kernel use-after-free",
        ]

        for query in queries:
            results = self._query_nvd(query, max_results=50)
            for cve_data in results:
                cve = self._parse_cve(cve_data)
                if cve and cve.cvss_score >= 7.0:
                    if not any(c.cve_id == cve.cve_id for c in cves):
                        cves.append(cve)

        return cves

    def get_cve_details(self, cve_id: str) -> Optional[LiveCVE]:
        """Get detailed information about a specific CVE."""
        params = {"cveId": cve_id}

        try:
            response = self.session.get(self.BASE_URL, params=params, timeout=30)
            if response.status_code == 200:
                data = response.json()
                cves = data.get("vulnerabilities", [])
                if cves:
                    return self._parse_cve(cves[0])
        except Exception as e:
            logger.error(f"Error fetching {cve_id}: {e}")

        return None

    def _query_nvd(self, keyword: str, max_results: int = 100) -> list:
        """Query NVD API with keyword search."""
        params: dict[str, str] = {
            "keywordSearch": keyword,
            "resultsPerPage": str(min(max_results, 100))
        }

        try:
            response = self.session.get(self.BASE_URL, params=params, timeout=60)
            if response.status_code == 200:
                data = response.json()
                return data.get("vulnerabilities", [])
            else:
                logger.warning(f"NVD API error: {response.status_code}")
        except Exception as e:
            logger.error(f"NVD query failed: {e}")

        return []

    def _parse_cve(self, cve_data: dict) -> Optional[LiveCVE]:
        """Parse CVE data from NVD API response."""
        try:
            cve = cve_data.get("cve", {})
            cve_id = cve.get("id", "")
            published = cve.get("published", "")

            # Get description
            descriptions = cve.get("descriptions", [])
            description = ""
            for d in descriptions:
                if d.get("lang") == "en":
                    description = d.get("value", "")
                    break

            # Get CVSS metrics
            metrics = cve.get("metrics", {})
            cvss_score = 0.0
            severity = "UNKNOWN"
            attack_vector = "NETWORK"

            if "cvssMetricV31" in metrics:
                cvss_data = metrics["cvssMetricV31"][0]["cvssData"]
                cvss_score = cvss_data.get("baseScore", 0)
                severity = cvss_data.get("baseSeverity", "UNKNOWN")
                attack_vector = cvss_data.get("attackVector", "NETWORK")
            elif "cvssMetricV30" in metrics:
                cvss_data = metrics["cvssMetricV30"][0]["cvssData"]
                cvss_score = cvss_data.get("baseScore", 0)
                severity = cvss_data.get("baseSeverity", "UNKNOWN")
                attack_vector = cvss_data.get("attackVector", "NETWORK")

            # Get references (for finding PoCs)
            references = []
            for ref in cve.get("references", []):
                url = ref.get("url", "")
                tags = ref.get("tags", [])
                references.append({
                    "url": url,
                    "tags": tags,
                    "is_exploit": "Exploit" in tags or "github.com" in url
                })

            # Get CWE IDs
            cwe_ids = []
            for weakness in cve.get("weaknesses", []):
                for desc in weakness.get("description", []):
                    if desc.get("value", "").startswith("CWE-"):
                        cwe_ids.append(desc["value"])

            # Determine exploit maturity from references
            exploit_maturity = "UNPROVEN"
            for ref in references:
                if ref["is_exploit"]:
                    exploit_maturity = "POC"
                    break

            return LiveCVE(
                cve_id=cve_id,
                published=published,
                cvss_score=cvss_score,
                severity=severity,
                description=description,
                attack_vector=attack_vector,
                exploit_maturity=exploit_maturity,
                references=references,
                cwe_ids=cwe_ids
            )

        except Exception as e:
            logger.debug(f"Error parsing CVE: {e}")
            return None


def find_exploitable_cves(device_id: str) -> list:
    """
    Convenience function to find exploitable CVEs for a device.

    Usage:
        cves = find_exploitable_cves("127.0.0.1:6562")
        for cve in cves:
            print(f"{cve.cve_id}: {cve.cvss_score}")
    """
    import subprocess

    # Get device info
    def adb_prop(prop):
        result = subprocess.run(
            ["adb", "-s", device_id, "shell", f"getprop {prop}"],
            capture_output=True, text=True, timeout=10
        )
        return result.stdout.strip()

    android_version = adb_prop("ro.build.version.release")
    security_patch = adb_prop("ro.build.version.security_patch")
    kernel = subprocess.run(
        ["adb", "-s", device_id, "shell", "uname -r"],
        capture_output=True, text=True, timeout=10
    ).stdout.strip()

    print(f"Device: Android {android_version}, Patch: {security_patch}")
    print(f"Kernel: {kernel}")
    print("-" * 50)

    # Find CVEs
    matcher = NVDLiveMatcher()

    # Get Android-specific CVEs
    android_cves = matcher.find_unpatched_cves(
        android_version=android_version,
        security_patch=security_patch
    )

    # Get kernel CVEs
    kernel_cves = matcher.find_kernel_exploits(kernel)

    # Combine and deduplicate
    all_cves = android_cves.copy()
    for cve in kernel_cves:
        if not any(c.cve_id == cve.cve_id for c in all_cves):
            all_cves.append(cve)

    # Sort by exploitability
    all_cves.sort(key=lambda c: (c.exploit_maturity == "POC", c.cvss_score), reverse=True)

    return all_cves


if __name__ == "__main__":
    # Test with Android 14 device
    import sys

    device_id = sys.argv[1] if len(sys.argv) > 1 else "127.0.0.1:6562"

    print(f"Finding exploitable CVEs for {device_id}...")
    print("=" * 60)

    cves = find_exploitable_cves(device_id)

    print(f"\nFound {len(cves)} potentially exploitable CVEs:\n")

    for i, cve in enumerate(cves[:10], 1):
        poc_marker = "ðŸ”´ PoC Available" if cve.exploit_maturity == "POC" else ""
        print(f"{i}. {cve.cve_id} (CVSS: {cve.cvss_score}, {cve.severity}) {poc_marker}")
        print(f"   Published: {cve.published[:10]}")
        print(f"   Attack Vector: {cve.attack_vector}")
        print(f"   {cve.description[:100]}...")
        print()
