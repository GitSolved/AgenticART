"""
PoC Fetcher - Retrieves real exploit code for CVEs.

Bridges the gap between "template" exploits and working code by:
1. Searching exploit databases for public PoCs
2. Fetching exploit code from GitHub security advisories
3. Providing real code for LLM to adapt

Sources:
- GitHub Security Advisories
- Exploit-DB (via API)
- Android Security Bulletins
- Google Project Zero
"""

import logging
from dataclasses import dataclass
from typing import Optional

import requests

logger = logging.getLogger(__name__)


@dataclass
class ExploitPoC:
    """Proof of Concept exploit data."""
    cve_id: str
    title: str
    source: str
    url: str
    code: Optional[str] = None
    language: str = "unknown"
    verified: bool = False


class PoCFetcher:
    """
    Fetches real PoC code from public sources.

    Usage:
        fetcher = PoCFetcher()
        pocs = fetcher.search("CVE-2023-40088")
        for poc in pocs:
            print(poc.code)
    """

    GITHUB_API = "https://api.github.com"
    EXPLOITDB_API = "https://exploit-db.com/search"

    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            "User-Agent": "AgenticART/1.0 (Security Research)",
            "Accept": "application/vnd.github.v3+json",
        })

    def search(self, cve_id: str) -> list[ExploitPoC]:
        """Search all sources for PoCs."""
        results = []

        # Search GitHub
        results.extend(self._search_github(cve_id))

        # Search known Android exploit repos
        results.extend(self._search_android_repos(cve_id))

        return results

    def _search_github(self, cve_id: str) -> list[ExploitPoC]:
        """Search GitHub for PoC repositories."""
        results = []

        try:
            # Search code
            url = f"{self.GITHUB_API}/search/code"
            params = {
                "q": f"{cve_id} language:python language:c",
                "per_page": 5,
            }

            resp = self.session.get(url, params=params, timeout=10)
            if resp.status_code == 200:
                data = resp.json()
                for item in data.get("items", []):
                    results.append(ExploitPoC(
                        cve_id=cve_id,
                        title=item.get("name", ""),
                        source="github",
                        url=item.get("html_url", ""),
                        language=self._detect_language(item.get("name", "")),
                    ))

            # Search repositories
            url = f"{self.GITHUB_API}/search/repositories"
            params = {
                "q": f"{cve_id} android exploit poc",
                "per_page": 5,
            }

            resp = self.session.get(url, params=params, timeout=10)
            if resp.status_code == 200:
                data = resp.json()
                for repo in data.get("items", []):
                    results.append(ExploitPoC(
                        cve_id=cve_id,
                        title=repo.get("name", ""),
                        source="github-repo",
                        url=repo.get("html_url", ""),
                    ))

        except Exception as e:
            logger.warning(f"GitHub search failed: {e}")

        return results

    def _search_android_repos(self, cve_id: str) -> list[ExploitPoC]:
        """Search known Android security research repos."""
        results = []

        # Known repos with Android exploits
        known_repos = [
            "AylaAi/CVE-2023-40088",
            "nickyoungzzz/CVE-2023-40088",
            "Snoopy-Sec/Localroot-ALL-CVE",
        ]

        cve_normalized = cve_id.lower().replace("-", "")

        for repo in known_repos:
            if cve_normalized in repo.lower().replace("-", ""):
                results.append(ExploitPoC(
                    cve_id=cve_id,
                    title=repo.split("/")[-1],
                    source="known-repo",
                    url=f"https://github.com/{repo}",
                ))

        return results

    def fetch_code(self, poc: ExploitPoC) -> Optional[str]:
        """Fetch actual exploit code from a PoC source."""
        try:
            if "github.com" in poc.url:
                # Convert to raw URL
                raw_url = poc.url.replace(
                    "github.com", "raw.githubusercontent.com"
                ).replace("/blob/", "/")

                resp = self.session.get(raw_url, timeout=10)
                if resp.status_code == 200:
                    poc.code = resp.text
                    return resp.text

        except Exception as e:
            logger.warning(f"Failed to fetch code: {e}")

        return None

    def _detect_language(self, filename: str) -> str:
        """Detect programming language from filename."""
        ext_map = {
            ".py": "python",
            ".c": "c",
            ".cpp": "cpp",
            ".java": "java",
            ".sh": "bash",
            ".smali": "smali",
        }
        for ext, lang in ext_map.items():
            if filename.endswith(ext):
                return lang
        return "unknown"


# Known working exploits for common scenarios
KNOWN_EXPLOITS: dict[str, dict] = {
    # Rooting methods that actually work
    "emulator-root": {
        "name": "Genymotion/Emulator Root",
        "method": "boot-image",
        "description": "Root via patched boot image",
        "steps": [
            "1. Extract boot.img from device/emulator",
            "2. Patch with Magisk: magiskboot unpack boot.img",
            "3. Flash patched boot: adb push patched_boot.img /sdcard/",
            "4. Reboot to recovery and flash",
        ],
        "code": '''
import subprocess
import os

def root_via_magisk(device_id):
    """Root device via Magisk boot image patching."""

    # Step 1: Pull boot image (requires unlocked bootloader)
    print("[*] Extracting boot image...")
    subprocess.run(["adb", "-s", device_id, "pull",
                   "/dev/block/by-name/boot", "boot.img"])

    # Step 2: Patch with Magisk (requires Magisk app)
    print("[*] Push Magisk APK...")
    subprocess.run(["adb", "-s", device_id, "install", "Magisk.apk"])

    # Step 3: Patch boot image via Magisk app
    print("[*] Patch boot image in Magisk app")
    print("[!] Manual step: Open Magisk -> Install -> Select boot.img")

    # Step 4: Flash patched image
    print("[*] Flash patched boot image...")
    subprocess.run(["adb", "-s", device_id, "reboot", "bootloader"])
    subprocess.run(["fastboot", "flash", "boot", "patched_boot.img"])
    subprocess.run(["fastboot", "reboot"])

    return True
'''
    },

    "dirty-pipe": {
        "name": "CVE-2022-0847 (Dirty Pipe)",
        "method": "kernel-exploit",
        "affected": "Linux kernel 5.8+, Android 12+",
        "code": '''
# Dirty Pipe - requires kernel 5.8 to 5.16.11
# This is a template - real exploit needs compilation for target

import subprocess

def check_vulnerable(device_id):
    """Check if device is vulnerable to Dirty Pipe."""
    result = subprocess.run(
        ["adb", "-s", device_id, "shell", "uname -r"],
        capture_output=True, text=True
    )
    kernel = result.stdout.strip()

    # Parse version
    match = re.match(r"(\\d+)\\.(\\d+)\\.(\\d+)", kernel)
    if match:
        major, minor, patch = map(int, match.groups())
        # Vulnerable: 5.8 <= version < 5.16.11
        if major == 5 and 8 <= minor < 17:
            return True, kernel

    return False, kernel

def exploit_dirty_pipe(device_id):
    """Exploit Dirty Pipe to gain root."""
    vulnerable, kernel = check_vulnerable(device_id)

    if not vulnerable:
        print(f"[FAILED] Kernel {kernel} not vulnerable to Dirty Pipe")
        return False

    print(f"[*] Kernel {kernel} may be vulnerable")

    # Push exploit binary (needs to be compiled for target arch)
    # Real exploit: https://github.com/Arinerron/CVE-2022-0847-DirtyPipe-Exploit

    print("[!] Dirty Pipe requires compiled binary for target architecture")
    print("[!] See: github.com/Arinerron/CVE-2022-0847-DirtyPipe-Exploit")

    return False
'''
    },
}


def get_rooting_options(device_info: dict) -> list[dict]:
    """Get applicable rooting options for a device."""
    options: list[dict] = []

    android_version = int(device_info.get("api_level", 0))
    device_info.get("kernel", "")

    # Check for Dirty Pipe vulnerability
    if android_version >= 31:  # Android 12+
        options.append(KNOWN_EXPLOITS["dirty-pipe"])

    # Magisk method always available if bootloader unlockable
    options.append(KNOWN_EXPLOITS["emulator-root"])

    return options
