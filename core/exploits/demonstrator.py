"""
1-Day Vulnerability Demonstrator

End-to-end demonstration of known vulnerabilities using LLM-generated exploits.
"""

import json
import logging
import re
import subprocess
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Optional

logger = logging.getLogger(__name__)


@dataclass
class DeviceProfile:
    """Target device profile."""
    device_id: str
    android_version: str
    api_level: int
    security_patch: str
    kernel_version: Optional[str] = None
    manufacturer: Optional[str] = None
    model: Optional[str] = None
    arch: str = "arm64"
    is_rooted: bool = False
    selinux_status: str = "enforcing"


@dataclass
class ExploitAttempt:
    """Record of an exploitation attempt."""
    cve_id: str
    adapted_code: str
    execution_output: str
    success: bool
    timestamp: datetime = field(default_factory=datetime.now)
    error: Optional[str] = None


@dataclass
class DemonstrationReport:
    """Report of 1-day demonstration."""
    device: DeviceProfile
    target_cve: str
    vulnerability_class: str
    attempts: list
    final_success: bool
    proof_of_exploitation: Optional[str] = None
    recommendations: list = field(default_factory=list)
    timestamp: datetime = field(default_factory=datetime.now)


class OneDayDemonstrator:
    """
    Demonstrates 1-day vulnerabilities on target devices.

    Usage:
        demo = OneDayDemonstrator(device_id="127.0.0.1:6555")
        report = demo.demonstrate("CVE-2024-43201")
    """

    def __init__(
        self,
        device_id: str,
        llm_client=None,
        max_attempts: int = 2,
        output_dir: str = "output/demonstrations",
    ):
        self.device_id = device_id
        self.max_attempts = max_attempts
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # LLM client
        if llm_client is None:
            from agent import LLMClient
            self.llm_client = LLMClient.create()
        else:
            self.llm_client = llm_client

        self._device_profile: Optional[DeviceProfile] = None

    @property
    def device(self) -> DeviceProfile:
        """Get device profile."""
        if self._device_profile is None:
            self._device_profile = self._profile_device()
        return self._device_profile

    def _profile_device(self) -> DeviceProfile:
        """Profile target device via ADB."""
        def adb_cmd(cmd: str) -> str:
            result = subprocess.run(
                ["adb", "-s", self.device_id, "shell", cmd],
                capture_output=True, text=True, timeout=10
            )
            return result.stdout.strip()

        android_version = adb_cmd("getprop ro.build.version.release")
        api_level = int(adb_cmd("getprop ro.build.version.sdk") or "0")
        security_patch = adb_cmd("getprop ro.build.version.security_patch")
        kernel = adb_cmd("uname -r")
        manufacturer = adb_cmd("getprop ro.product.manufacturer")
        model = adb_cmd("getprop ro.product.model")

        # Check root
        root_check = adb_cmd("su -c 'id' 2>/dev/null || echo 'not_root'")
        is_rooted = "uid=0" in root_check

        # Check SELinux
        selinux = adb_cmd("getenforce 2>/dev/null || echo 'unknown'")

        # Architecture
        arch = adb_cmd("uname -m")
        if "aarch64" in arch or "arm64" in arch:
            arch = "arm64"
        elif "x86_64" in arch:
            arch = "x86_64"

        return DeviceProfile(
            device_id=self.device_id,
            android_version=android_version,
            api_level=api_level,
            security_patch=security_patch,
            kernel_version=kernel,
            manufacturer=manufacturer,
            model=model,
            arch=arch,
            is_rooted=is_rooted,
            selinux_status=selinux.lower(),
        )

    def demonstrate(self, cve_id: str) -> DemonstrationReport:
        """Demonstrate a specific CVE."""
        logger.info(f"Starting demonstration: {cve_id}")

        attempts: list[ExploitAttempt] = []
        final_success = False

        for attempt_num in range(1, self.max_attempts + 1):
            logger.info(f"Attempt {attempt_num}/{self.max_attempts}")

            try:
                # Generate exploit with LLM
                code = self._generate_exploit(cve_id, attempts)

                # Execute
                output, success = self._execute_exploit(code)

                attempt = ExploitAttempt(
                    cve_id=cve_id,
                    adapted_code=code,
                    execution_output=output,
                    success=success,
                )
                attempts.append(attempt)

                if success:
                    final_success = True
                    logger.info(f"Exploitation successful on attempt {attempt_num}!")
                    break

            except Exception as e:
                logger.error(f"Attempt {attempt_num} error: {e}")
                attempts.append(ExploitAttempt(
                    cve_id=cve_id,
                    adapted_code="",
                    execution_output="",
                    success=False,
                    error=str(e),
                ))

        report = DemonstrationReport(
            device=self.device,
            target_cve=cve_id,
            vulnerability_class="unknown",
            attempts=attempts,
            final_success=final_success,
            recommendations=self._get_recommendations(cve_id, final_success),
        )

        self._save_report(report)
        return report

    def _generate_exploit(self, cve_id: str, previous_attempts: list) -> str:
        """Generate exploit code using LLM."""

        prompt = f"""Generate a Python exploit script for {cve_id}.

Target Device:
- Device: {self.device.manufacturer} {self.device.model}
- Android: {self.device.android_version} (API {self.device.api_level})
- Kernel: {self.device.kernel_version}
- ADB ID: {self.device.device_id}
- Rooted: {self.device.is_rooted}
- SELinux: {self.device.selinux_status}

Requirements:
1. Use ADB commands via subprocess
2. Target device ID: {self.device.device_id}
3. Include verification of exploit success
4. Print "[SUCCESS]" if exploit works, "[FAILED]" otherwise
"""

        if previous_attempts:
            last = previous_attempts[-1]
            prompt += f"""

Previous attempt failed with:
{last.execution_output[:500] if last.execution_output else last.error}

Fix the issues and try a different approach.
"""

        prompt += "\n\nOutput ONLY executable Python code, no markdown or explanations."

        system = "You are an Android security researcher. Generate working exploit code for authorized penetration testing."

        response = self.llm_client.complete(prompt, system=system)

        # Extract code
        code = response.content

        # Remove markdown if present
        if "```python" in code:
            match = re.search(r"```python\n(.*?)```", code, re.DOTALL)
            if match:
                code = match.group(1)
        elif "```" in code:
            match = re.search(r"```\n?(.*?)```", code, re.DOTALL)
            if match:
                code = match.group(1)

        return code.strip()

    def _execute_exploit(self, code: str) -> tuple:
        """Execute exploit and check for success."""
        exploit_path = self.output_dir / "current_exploit.py"
        exploit_path.write_text(code)

        try:
            result = subprocess.run(
                ["python3", str(exploit_path)],
                capture_output=True,
                text=True,
                timeout=120,
                env={**__import__("os").environ, "DEVICE_ID": self.device_id},
            )
            output = result.stdout + result.stderr

            # Check success indicators
            success = any(s in output for s in ["[SUCCESS]", "uid=0", "root", "SUCCESS"])

            return output, success

        except subprocess.TimeoutExpired:
            return "Timeout", False
        except Exception as e:
            return str(e), False

    def _get_recommendations(self, cve_id: str, exploited: bool) -> list:
        """Generate recommendations."""
        if exploited:
            return [
                f"CRITICAL: Device is vulnerable to {cve_id}",
                f"Update security patch (current: {self.device.security_patch})",
                "Apply vendor security updates immediately",
            ]
        return [
            f"Device may not be vulnerable to {cve_id}",
            "Continue monitoring for new vulnerabilities",
            "Keep security patches up to date",
        ]

    def _save_report(self, report: DemonstrationReport):
        """Save report to file."""
        ts = datetime.now().strftime("%Y%m%d_%H%M%S")
        path = self.output_dir / f"report_{report.target_cve}_{ts}.json"

        data = {
            "cve": report.target_cve,
            "device": {
                "id": report.device.device_id,
                "android": report.device.android_version,
                "patch": report.device.security_patch,
            },
            "attempts": len(report.attempts),
            "success": report.final_success,
            "recommendations": report.recommendations,
        }

        path.write_text(json.dumps(data, indent=2))
        logger.info(f"Report saved: {path}")

    def list_applicable_cves(self) -> list:
        """List CVEs that may affect this device."""
        from core.scanning.cve_matcher import CVEMatcher

        matcher = CVEMatcher()
        matches = matcher.match_device(
            android_version=self.device.android_version,
            api_level=self.device.api_level,
            security_patch=self.device.security_patch,
        )

        return [cve.cve_id for cve in matches[:20]]
