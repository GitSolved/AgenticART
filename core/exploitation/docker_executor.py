"""
Docker Executor

Executes scripts in isolated Docker containers with:
- Non-root user
- Read-only filesystem
- Dropped capabilities
- Memory/CPU limits
- Restricted network access
"""

import logging
import os
import subprocess
import uuid
from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional

logger = logging.getLogger(__name__)


@dataclass
class DockerConfig:
    """Configuration for Docker-based sandbox execution."""

    image_name: str = "agentic-sandbox:latest"
    network: str = "agentic-sandbox-net"
    memory_limit: str = "512m"
    cpu_quota: int = 50000  # 50% of one CPU core
    user: str = "pentester"

    # Security settings
    read_only: bool = True
    no_new_privileges: bool = True
    drop_capabilities: list[str] = field(default_factory=lambda: ["ALL"])
    add_capabilities: list[str] = field(default_factory=lambda: ["NET_RAW"])

    # Emulator connection
    emulator_device: str = ""

    @classmethod
    def from_env(cls) -> "DockerConfig":
        """Create config from environment variables."""
        return cls(
            image_name=os.getenv("DOCKER_SANDBOX_IMAGE", "agentic-sandbox:latest"),
            network=os.getenv("DOCKER_SANDBOX_NETWORK", "agentic-sandbox-net"),
            memory_limit=os.getenv("DOCKER_SANDBOX_MEMORY", "512m"),
            emulator_device=os.getenv("EMULATOR_DEVICE", "host.docker.internal:5555"),
        )


@dataclass
class DockerExecutionResult:
    """Result of Docker-based script execution."""

    success: bool
    stdout: str
    stderr: str
    return_code: int
    duration_seconds: float
    script_path: str
    container_id: Optional[str] = None


class DockerExecutor:
    """
    Execute scripts in isolated Docker containers.

    Security features:
    - Non-root execution (pentester user)
    - Read-only root filesystem
    - All capabilities dropped except NET_RAW
    - Memory and CPU limits
    - No privilege escalation
    - Restricted network (emulator access only)
    """

    def __init__(
        self,
        config: Optional[DockerConfig] = None,
        timeout: int = 300,
        log_dir: str = "output/logs",
    ):
        """
        Initialize the Docker executor.

        Args:
            config: Docker configuration. Uses environment defaults if None.
            timeout: Execution timeout in seconds.
            log_dir: Directory for execution logs.
        """
        self.config = config or DockerConfig.from_env()
        self.timeout = timeout
        self.log_dir = log_dir
        os.makedirs(log_dir, exist_ok=True)

    def execute(
        self,
        script_path: str,
        env_vars: Optional[dict] = None,
        working_dir: Optional[str] = None,
    ) -> DockerExecutionResult:
        """
        Execute a script in an isolated Docker container.

        Args:
            script_path: Path to script file on host
            env_vars: Additional environment variables
            working_dir: Ignored (container uses /workspace)

        Returns:
            DockerExecutionResult with output and status
        """
        container_name = f"sandbox-{uuid.uuid4().hex[:8]}"
        start_time = datetime.now()

        # Determine interpreter based on extension
        interpreter = self._get_interpreter(script_path)

        # Build docker run command
        cmd = self._build_docker_command(
            script_path=script_path,
            interpreter=interpreter,
            container_name=container_name,
            env_vars=env_vars,
        )

        logger.info(f"Executing in Docker sandbox: {script_path}")
        logger.debug(f"Docker command: {' '.join(cmd[:15])}...")

        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=self.timeout + 10,  # Extra buffer for container startup
                encoding="utf-8",
                errors="replace",
            )

            duration = (datetime.now() - start_time).total_seconds()

            execution_result = DockerExecutionResult(
                success=result.returncode == 0,
                stdout=result.stdout,
                stderr=result.stderr,
                return_code=result.returncode,
                duration_seconds=duration,
                script_path=script_path,
                container_id=container_name,
            )

            self._log_execution(execution_result)
            return execution_result

        except subprocess.TimeoutExpired:
            duration = (datetime.now() - start_time).total_seconds()
            logger.error(f"Container timed out after {self.timeout}s")

            # Force kill the container
            self._kill_container(container_name)

            return DockerExecutionResult(
                success=False,
                stdout="",
                stderr=f"Container execution timed out after {self.timeout} seconds",
                return_code=-1,
                duration_seconds=duration,
                script_path=script_path,
                container_id=container_name,
            )

        except Exception as e:
            duration = (datetime.now() - start_time).total_seconds()
            logger.error(f"Docker execution error: {e}")

            return DockerExecutionResult(
                success=False,
                stdout="",
                stderr=str(e),
                return_code=-1,
                duration_seconds=duration,
                script_path=script_path,
            )

    def _build_docker_command(
        self,
        script_path: str,
        interpreter: str,
        container_name: str,
        env_vars: Optional[dict] = None,
    ) -> list[str]:
        """Build the docker run command with security constraints."""
        # Convert Windows path to Unix path for Docker volume mount
        abs_script_path = os.path.abspath(script_path)

        cmd = [
            "docker", "run",
            "--rm",  # Auto-cleanup container
            "--name", container_name,

            # Resource limits
            "--memory", self.config.memory_limit,
            "--cpu-quota", str(self.config.cpu_quota),

            # Security constraints
            "--user", self.config.user,
            "--security-opt", "no-new-privileges:true",

            # Capabilities
            "--cap-drop", "ALL",
            "--cap-add", "NET_RAW",

            # Network - restricted to sandbox network
            "--network", self.config.network,

            # Tmpfs for writable directories
            "--tmpfs", "/tmp:rw,noexec,nosuid,size=64m",

            # Mount script as read-only
            "-v", f"{abs_script_path}:/workspace/script:ro",

            # Environment variables
            "-e", f"EMULATOR_DEVICE={self.config.emulator_device}",
        ]

        # Add read-only flag if enabled
        if self.config.read_only:
            cmd.append("--read-only")

        # Add extra environment variables
        if env_vars:
            for key, value in env_vars.items():
                cmd.extend(["-e", f"{key}={value}"])

        # Add image and command
        cmd.extend([
            self.config.image_name,
            interpreter, "/workspace/script"
        ])

        return cmd

    def _get_interpreter(self, script_path: str) -> str:
        """Determine script interpreter based on file extension."""
        if script_path.endswith(".py"):
            return "python3"
        elif script_path.endswith(".sh"):
            return "bash"
        else:
            return "sh"

    def _kill_container(self, container_name: str) -> None:
        """Force kill a container by name."""
        try:
            subprocess.run(
                ["docker", "kill", container_name],
                capture_output=True,
                timeout=10,
            )
        except Exception as e:
            logger.warning(f"Failed to kill container {container_name}: {e}")

    def _log_execution(self, result: DockerExecutionResult) -> None:
        """Log execution result to file."""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        script_name = os.path.basename(result.script_path)
        log_file = os.path.join(
            self.log_dir,
            f"docker_exec_{timestamp}_{script_name}.log"
        )

        with open(log_file, "w") as f:
            f.write(f"Script: {result.script_path}\n")
            f.write(f"Container: {result.container_id}\n")
            f.write(f"Success: {result.success}\n")
            f.write(f"Return Code: {result.return_code}\n")
            f.write(f"Duration: {result.duration_seconds:.2f}s\n")
            f.write("\n--- STDOUT ---\n")
            f.write(result.stdout)
            f.write("\n--- STDERR ---\n")
            f.write(result.stderr)

        logger.debug(f"Execution logged to: {log_file}")

    def check_docker_available(self) -> tuple[bool, str]:
        """
        Check if Docker is available and the sandbox image exists.

        Returns:
            Tuple of (available, message)
        """
        try:
            # Check Docker daemon
            result = subprocess.run(
                ["docker", "info"],
                text=True,
                capture_output=True,
                timeout=10,
            )
            if result.returncode != 0:
                return False, "Docker daemon not running"

            # Check sandbox image exists
            result = subprocess.run(
                ["docker", "images", "-q", self.config.image_name],
                capture_output=True,
                text=True,
                timeout=10,
            )
            if not result.stdout.strip():
                return False, f"Sandbox image '{self.config.image_name}' not found. Run: docker-compose build sandbox"

            # Check network exists
            result = subprocess.run(
                ["docker", "network", "inspect", self.config.network],
                capture_output=True,
                text=True,
                timeout=10,
            )
            if result.returncode != 0:
                return False, f"Sandbox network '{self.config.network}' not found. Run: docker-compose up -d"

            return True, "Docker sandbox ready"

        except FileNotFoundError:
            return False, "Docker not installed"
        except subprocess.TimeoutExpired:
            return False, "Docker command timed out"
        except Exception as e:
            return False, f"Docker check failed: {e}"
