"""
Magisk Rooting Technique

Implements Magisk-based systemless root for Android devices.
Referenced in the paper as one of the primary rooting methods.
"""

import logging
from dataclasses import dataclass
from enum import Enum
from typing import Optional

from ...reconnaissance import ADBConnection

logger = logging.getLogger(__name__)


class MagiskInstallMethod(Enum):
    PATCHED_BOOT = "patched_boot"       # Patch and flash boot image
    RECOVERY = "recovery"                # Install via custom recovery
    DIRECT_INSTALL = "direct_install"    # Direct install (already rooted)


@dataclass
class MagiskConfig:
    """Configuration for Magisk installation."""
    apk_path: str = "magisk.apk"
    version: str = "latest"
    hide_enabled: bool = True
    denylist: list[str] = None

    def __post_init__(self):
        if self.denylist is None:
            self.denylist = [
                "com.google.android.gms",  # Google Play Services
                "com.android.vending",      # Play Store
            ]


class MagiskRooter:
    """
    Implements Magisk systemless root.

    Magisk provides:
    - Systemless root (doesn't modify /system)
    - MagiskHide for root detection bypass
    - Module support for customization
    """

    def __init__(self, adb: ADBConnection, config: Optional[MagiskConfig] = None):
        self.adb = adb
        self.config = config or MagiskConfig()

    def check_compatibility(self) -> dict:
        """
        Check if device is compatible with Magisk.

        Returns:
            Dict with compatibility info
        """
        logger.info("Checking Magisk compatibility...")

        return {
            "bootloader_unlocked": self._check_bootloader(),
            "verified_boot": self._get_verified_boot_state(),
            "architecture": self._get_arch(),
            "android_version": self._get_android_version(),
            "existing_root": self._check_existing_root(),
            "compatible": True,  # Simplified - real implementation would evaluate
        }

    def _check_bootloader(self) -> bool:
        """Check if bootloader is unlocked."""
        state = self.adb.get_prop("ro.boot.flash.locked")
        return state == "0"

    def _get_verified_boot_state(self) -> str:
        return self.adb.get_prop("ro.boot.verifiedbootstate")

    def _get_arch(self) -> str:
        return self.adb.get_prop("ro.product.cpu.abi")

    def _get_android_version(self) -> str:
        return self.adb.get_prop("ro.build.version.release")

    def _check_existing_root(self) -> bool:
        output = self.adb.shell("which su")
        return "su" in output and "not found" not in output.lower()

    def get_boot_image(self, output_path: str) -> bool:
        """
        Extract current boot image for patching.

        Args:
            output_path: Where to save the boot image

        Returns:
            True if successful
        """
        logger.info("Extracting boot image...")

        # Find boot partition
        boot_partition = self._find_boot_partition()
        if not boot_partition:
            logger.error("Could not find boot partition")
            return False

        # Extract boot image
        temp_path = "/data/local/tmp/boot.img"
        result = self.adb.shell(f"dd if={boot_partition} of={temp_path}")

        if "error" in result.lower():
            logger.error(f"Failed to extract boot image: {result}")
            return False

        # Pull to host
        stdout, stderr, code = self.adb.execute(f"pull {temp_path} {output_path}")
        return code == 0

    def _find_boot_partition(self) -> Optional[str]:
        """Find the boot partition path."""
        # Common locations
        locations = [
            "/dev/block/by-name/boot",
            "/dev/block/platform/*/by-name/boot",
            "/dev/block/bootdevice/by-name/boot",
        ]

        for loc in locations:
            result = self.adb.shell(f"ls {loc} 2>/dev/null")
            if result and "No such file" not in result:
                return result.strip()

        # Fallback: parse fstab
        fstab = self.adb.shell("cat /vendor/etc/fstab.* 2>/dev/null | grep boot")
        if fstab:
            parts = fstab.split()
            if parts:
                return parts[0]

        return None

    def install_magisk_app(self) -> bool:
        """Install Magisk Manager app."""
        logger.info("Installing Magisk app...")

        # Push APK
        self.adb.execute(f"push {self.config.apk_path} /data/local/tmp/magisk.apk")

        # Install
        result = self.adb.shell("pm install /data/local/tmp/magisk.apk")
        return "Success" in result

    def flash_patched_boot(self, patched_boot_path: str) -> bool:
        """
        Flash a patched boot image.

        Args:
            patched_boot_path: Path to Magisk-patched boot.img

        Returns:
            True if successful
        """
        logger.info("Flashing patched boot image...")

        boot_partition = self._find_boot_partition()
        if not boot_partition:
            return False

        # Push patched boot
        temp_path = "/data/local/tmp/patched_boot.img"
        stdout, stderr, code = self.adb.execute(f"push {patched_boot_path} {temp_path}")
        if code != 0:
            return False

        # Flash (requires root or unlocked bootloader + fastboot)
        result = self.adb.shell(f"dd if={temp_path} of={boot_partition}")
        return "error" not in result.lower()

    def verify_root(self) -> dict:
        """
        Verify Magisk root is working.

        Returns:
            Dict with verification results
        """
        logger.info("Verifying Magisk root...")

        # Check su
        su_output = self.adb.shell("su -c 'id'")
        has_root = "uid=0" in su_output

        # Check Magisk version
        magisk_version = self.adb.shell("su -c 'magisk -v'")

        # Check MagiskHide/Denylist
        hide_status = self.adb.shell("su -c 'magisk --hide status'")

        return {
            "root_access": has_root,
            "magisk_version": magisk_version,
            "hide_enabled": "enabled" in hide_status.lower(),
            "su_path": self.adb.shell("which su"),
        }

    def configure_hide(self, apps: Optional[list[str]] = None) -> bool:
        """
        Configure MagiskHide/Denylist for specified apps.

        Args:
            apps: List of package names to hide root from

        Returns:
            True if successful
        """
        apps = apps or self.config.denylist

        for app in apps:
            result = self.adb.shell(f"su -c 'magisk --hide add {app}'")
            logger.info(f"Added {app} to hide list: {result}")

        return True

    def generate_install_script(self, method: MagiskInstallMethod) -> str:
        """
        Generate installation script for the specified method.

        This is what gets passed to the ScriptGenerator for refinement.
        """
        if method == MagiskInstallMethod.PATCHED_BOOT:
            return """#!/bin/bash
# Magisk Installation via Patched Boot Image
# Generated by LLM-Pentest

set -e

DEVICE_IP="${1:-192.168.56.101}"
MAGISK_APK="${2:-magisk.apk}"

echo "[*] Connecting to device..."
adb connect $DEVICE_IP

echo "[*] Extracting boot image..."
adb shell "dd if=/dev/block/by-name/boot of=/data/local/tmp/boot.img"
adb pull /data/local/tmp/boot.img ./original_boot.img

echo "[*] Installing Magisk app..."
adb push $MAGISK_APK /data/local/tmp/magisk.apk
adb shell pm install /data/local/tmp/magisk.apk

echo "[!] Manual step required:"
echo "    1. Open Magisk app on device"
echo "    2. Tap 'Install' next to Magisk"
echo "    3. Select 'Select and Patch a File'"
echo "    4. Navigate to /data/local/tmp/boot.img"
echo "    5. Wait for patching to complete"
echo "    6. Pull patched image: adb pull /storage/emulated/0/Download/magisk_patched*.img"

echo "[*] After patching, flash with:"
echo "    adb reboot bootloader"
echo "    fastboot flash boot magisk_patched.img"
echo "    fastboot reboot"
"""

        return "# Unsupported method"
