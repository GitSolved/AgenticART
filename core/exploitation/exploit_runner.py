"""
Exploit Runner

Safely executes generated exploitation scripts with:
- Docker-based sandboxing (DOCKER mode)
- Timeout handling
- Output capture
- Multiple execution modes (DRY_RUN, DOCKER, LIVE)
"""

import logging
import os
import subprocess
from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from typing import TYPE_CHECKING, Optional

if TYPE_CHECKING:
    from core.exploitation.docker_executor import DockerExecutor

logger = logging.getLogger(__name__)


class ExecutionMode(Enum):
    DRY_RUN = "dry_run"        # Parse and validate only
    DOCKER = "docker"          # Run in isolated Docker container
    LIVE = "live"              # Run against real target (no isolation)


@dataclass
class ExecutionResult:
    """Result of script execution."""
    success: bool
    stdout: str
    stderr: str
    return_code: int
    duration_seconds: float
    script_path: str
    mode: ExecutionMode


class ExploitRunner:
    """
    Safely executes exploitation scripts.

    Features:
    - Multiple execution modes:
      - DRY_RUN: Parse and validate only
      - DOCKER: Run in isolated Docker container (recommended)
      - LIVE: Run directly on host (no isolation)
    - Timeout enforcement
    - Output capture and logging
    """

    def __init__(
        self,
        mode: ExecutionMode = ExecutionMode.DRY_RUN,
        timeout: int = 300,
        log_dir: str = "output/logs",
    ):
        self.mode = mode
        self.timeout = timeout
        self.log_dir = log_dir
        os.makedirs(log_dir, exist_ok=True)

        # Initialize Docker executor for DOCKER mode
        self._docker_executor: Optional["DockerExecutor"] = None
        if mode == ExecutionMode.DOCKER:
            from core.exploitation.docker_executor import DockerExecutor
            self._docker_executor = DockerExecutor(timeout=timeout, log_dir=log_dir)

    def execute(
        self,
        script_path: str,
        env_vars: Optional[dict] = None,
        working_dir: Optional[str] = None,
    ) -> ExecutionResult:
        """
        Execute a script file.

        Args:
            script_path: Path to script file
            env_vars: Additional environment variables
            working_dir: Working directory for execution

        Returns:
            ExecutionResult with output and status
        """
        logger.info(f"Executing script: {script_path} (mode: {self.mode.value})")
        start_time = datetime.now()

        if self.mode == ExecutionMode.DRY_RUN:
            return self._dry_run(script_path)

        if self.mode == ExecutionMode.DOCKER:
            if self._docker_executor is None:
                raise RuntimeError("DockerExecutor not initialized")
            docker_result = self._docker_executor.execute(script_path, env_vars, working_dir)
            # Convert DockerExecutionResult to ExecutionResult
            return ExecutionResult(
                success=docker_result.success,
                stdout=docker_result.stdout,
                stderr=docker_result.stderr,
                return_code=docker_result.return_code,
                duration_seconds=docker_result.duration_seconds,
                script_path=docker_result.script_path,
                mode=self.mode,
            )

        # LIVE mode: Determine interpreter based on extension
        interpreter = self._get_interpreter(script_path)

        # Prepare environment
        env = os.environ.copy()
        if env_vars:
            env.update(env_vars)

        try:
            result = subprocess.run(
                [interpreter, script_path],
                capture_output=True,
                text=True,
                timeout=self.timeout,
                env=env,
                cwd=working_dir,
            )

            duration = (datetime.now() - start_time).total_seconds()

            execution_result = ExecutionResult(
                success=result.returncode == 0,
                stdout=result.stdout,
                stderr=result.stderr,
                return_code=result.returncode,
                duration_seconds=duration,
                script_path=script_path,
                mode=self.mode,
            )

            self._log_execution(execution_result)
            return execution_result

        except subprocess.TimeoutExpired:
            duration = (datetime.now() - start_time).total_seconds()
            logger.error(f"Script timed out after {self.timeout}s")
            return ExecutionResult(
                success=False,
                stdout="",
                stderr=f"Execution timed out after {self.timeout} seconds",
                return_code=-1,
                duration_seconds=duration,
                script_path=script_path,
                mode=self.mode,
            )

        except Exception as e:
            duration = (datetime.now() - start_time).total_seconds()
            logger.error(f"Execution error: {e}")
            return ExecutionResult(
                success=False,
                stdout="",
                stderr=str(e),
                return_code=-1,
                duration_seconds=duration,
                script_path=script_path,
                mode=self.mode,
            )

    def _dry_run(self, script_path: str) -> ExecutionResult:
        """Validate script without executing."""
        logger.info(f"Dry run: {script_path}")

        with open(script_path) as f:
            content = f.read()

        # Basic validation
        issues = []
        if script_path.endswith(".py"):
            try:
                compile(content, script_path, "exec")
            except SyntaxError as e:
                issues.append(f"Syntax error: {e}")

        return ExecutionResult(
            success=len(issues) == 0,
            stdout=f"[DRY RUN] Script validated: {script_path}\nLines: {len(content.splitlines())}",
            stderr="\n".join(issues) if issues else "",
            return_code=0 if not issues else 1,
            duration_seconds=0,
            script_path=script_path,
            mode=ExecutionMode.DRY_RUN,
        )

    def _get_interpreter(self, script_path: str) -> str:
        """Determine script interpreter."""
        if script_path.endswith(".py"):
            return "python3"
        elif script_path.endswith(".sh"):
            return "bash"
        else:
            return "sh"

    def _log_execution(self, result: ExecutionResult):
        """Log execution result to file."""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        log_file = os.path.join(
            self.log_dir,
            f"exec_{timestamp}_{os.path.basename(result.script_path)}.log"
        )

        with open(log_file, "w") as f:
            f.write(f"Script: {result.script_path}\n")
            f.write(f"Mode: {result.mode.value}\n")
            f.write(f"Success: {result.success}\n")
            f.write(f"Return Code: {result.return_code}\n")
            f.write(f"Duration: {result.duration_seconds:.2f}s\n")
            f.write("\n--- STDOUT ---\n")
            f.write(result.stdout)
            f.write("\n--- STDERR ---\n")
            f.write(result.stderr)

        logger.info(f"Execution logged to: {log_file}")

    def execute_command(
        self,
        command: str,
        shell: bool = True,
    ) -> ExecutionResult:
        """
        Execute a raw command (for simple ADB commands).

        Args:
            command: Command to execute
            shell: Whether to use shell

        Returns:
            ExecutionResult
        """
        if self.mode == ExecutionMode.DRY_RUN:
            return ExecutionResult(
                success=True,
                stdout=f"[DRY RUN] Would execute: {command}",
                stderr="",
                return_code=0,
                duration_seconds=0,
                script_path="<command>",
                mode=ExecutionMode.DRY_RUN,
            )

        start_time = datetime.now()

        try:
            result = subprocess.run(
                command if shell else command.split(),
                shell=shell,
                capture_output=True,
                text=True,
                timeout=self.timeout,
            )

            duration = (datetime.now() - start_time).total_seconds()

            return ExecutionResult(
                success=result.returncode == 0,
                stdout=result.stdout,
                stderr=result.stderr,
                return_code=result.returncode,
                duration_seconds=duration,
                script_path=f"<command:{command[:50]}>",
                mode=self.mode,
            )

        except Exception as e:
            duration = (datetime.now() - start_time).total_seconds()
            return ExecutionResult(
                success=False,
                stdout="",
                stderr=str(e),
                return_code=-1,
                duration_seconds=duration,
                script_path=f"<command:{command[:50]}>",
                mode=self.mode,
            )
