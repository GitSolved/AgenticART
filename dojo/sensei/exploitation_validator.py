"""
Exploitation Validator - Validates actual exploitation, not just command execution.

This module bridges the gap between "commands that run" and "exploitation that works"
by checking for CTF-style flags and state changes that prove successful exploitation.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import TYPE_CHECKING, Optional

if TYPE_CHECKING:
    from dojo.curriculum import ChallengeSession
    from dojo.curriculum.executor import Executor
    from dojo.models import Challenge
    from dojo.targets import TargetManager


class ExploitationType(Enum):
    """Types of exploitation validation."""

    FLAG_CAPTURE = "flag_capture"  # CTF-style flag in output
    DATA_EXFILTRATION = "data_exfiltration"  # Protected data accessed
    PRIVILEGE_ESCALATION = "privilege_escalation"  # Elevated privileges
    AUTH_BYPASS = "auth_bypass"  # Skipped authentication
    STATE_CHANGE = "state_change"  # System state modified


@dataclass
class ExploitationResult:
    """Result of exploitation validation."""

    success: bool
    exploitation_type: ExploitationType
    evidence: Optional[str] = None
    reason: Optional[str] = None
    flag_captured: Optional[str] = None
    timestamp: datetime = field(default_factory=datetime.now)

    def to_dict(self) -> dict:
        """Convert to dictionary."""
        return {
            "success": self.success,
            "exploitation_type": self.exploitation_type.value,
            "evidence": self.evidence,
            "reason": self.reason,
            "flag_captured": self.flag_captured,
            "timestamp": self.timestamp.isoformat(),
        }


@dataclass
class ExploitationConfig:
    """Configuration for exploitation validation on a challenge."""

    enabled: bool = False
    target_app: Optional[str] = None
    vulnerability_id: Optional[str] = None
    validation_type: ExploitationType = ExploitationType.FLAG_CAPTURE
    success_indicators: list[str] = field(default_factory=list)
    flag_value: Optional[str] = None

    @classmethod
    def from_dict(cls, data: dict) -> "ExploitationConfig":
        """Create from dictionary."""
        if not data:
            return cls(enabled=False)

        return cls(
            enabled=True,
            target_app=data.get("target_app"),
            vulnerability_id=data.get("vulnerability_id"),
            validation_type=ExploitationType(
                data.get("type", "flag_capture")
            ),
            success_indicators=data.get("success_indicators", []),
            flag_value=data.get("flag_value"),
        )


class ExploitationValidator:
    """
    Validates actual exploitation rather than just command execution.

    This validator checks for:
    - CTF-style flags that appear when exploitation succeeds
    - Protected data markers that indicate successful exfiltration
    - Privilege changes (uid=0, capabilities)
    - Authentication bypass indicators
    """

    def __init__(self, target_manager: Optional["TargetManager"] = None):
        """
        Initialize the exploitation validator.

        Args:
            target_manager: Manager for vulnerable targets. Created if not provided.
        """
        if target_manager is None:
            from dojo.targets import TargetManager
            target_manager = TargetManager()
        self.target_manager = target_manager

    def validate(
        self,
        challenge: "Challenge",
        session: "ChallengeSession",
        executor: Optional["Executor"] = None,
    ) -> ExploitationResult:
        """
        Validate exploitation for a challenge session.

        Args:
            challenge: The challenge being validated.
            session: The challenge session with attempts.
            executor: Optional executor for state checks.

        Returns:
            ExploitationResult indicating success or failure.
        """
        # Get exploitation config from challenge
        config = self._get_exploitation_config(challenge)

        if not config.enabled:
            # No exploitation validation configured
            return ExploitationResult(
                success=True,
                exploitation_type=ExploitationType.FLAG_CAPTURE,
                reason="No exploitation validation configured",
            )

        # Route to appropriate validation method
        if config.validation_type == ExploitationType.FLAG_CAPTURE:
            return self._validate_flag_capture(config, session)
        elif config.validation_type == ExploitationType.DATA_EXFILTRATION:
            return self._validate_data_exfiltration(config, session)
        elif config.validation_type == ExploitationType.PRIVILEGE_ESCALATION:
            return self._validate_privilege_escalation(config, session, executor)
        elif config.validation_type == ExploitationType.AUTH_BYPASS:
            return self._validate_auth_bypass(config, session)
        else:
            return self._validate_flag_capture(config, session)

    def _get_exploitation_config(self, challenge: "Challenge") -> ExploitationConfig:
        """Extract exploitation config from challenge."""
        # Check for exploitation_validation in additional_context
        exploit_data = challenge.inputs.additional_context.get(
            "exploitation_validation", {}
        )

        if exploit_data:
            config = ExploitationConfig.from_dict(exploit_data)

            # If target_app and vulnerability_id are specified, load from target manager
            if config.target_app and config.vulnerability_id:
                indicators = self.target_manager.get_success_indicators(
                    config.target_app, config.vulnerability_id
                )
                if indicators:
                    config.success_indicators = indicators

                flag = self.target_manager.get_flag_value(
                    config.target_app, config.vulnerability_id
                )
                if flag:
                    config.flag_value = flag

            return config

        return ExploitationConfig(enabled=False)

    def _validate_flag_capture(
        self,
        config: ExploitationConfig,
        session: "ChallengeSession",
    ) -> ExploitationResult:
        """
        Validate that a CTF-style flag was captured.

        Success criteria:
        - Flag string appears in command output
        - Or any success indicator appears in output
        """
        # Collect all output from attempts
        all_output = self._collect_output(session)

        # Check for exact flag match
        if config.flag_value:
            if config.flag_value in all_output:
                return ExploitationResult(
                    success=True,
                    exploitation_type=ExploitationType.FLAG_CAPTURE,
                    evidence=f"Flag captured: {config.flag_value}",
                    flag_captured=config.flag_value,
                )

        # Check for success indicators
        for indicator in config.success_indicators:
            if indicator.lower() in all_output.lower():
                return ExploitationResult(
                    success=True,
                    exploitation_type=ExploitationType.FLAG_CAPTURE,
                    evidence=f"Success indicator found: {indicator}",
                    flag_captured=indicator if indicator.startswith("FLAG{") else None,
                )

        return ExploitationResult(
            success=False,
            exploitation_type=ExploitationType.FLAG_CAPTURE,
            reason="Flag not found in output",
        )

    def _validate_data_exfiltration(
        self,
        config: ExploitationConfig,
        session: "ChallengeSession",
    ) -> ExploitationResult:
        """
        Validate that protected data was exfiltrated.

        Success criteria:
        - Protected data markers appear in output
        - Data that should not be accessible was accessed
        """
        all_output = self._collect_output(session)

        for indicator in config.success_indicators:
            if indicator in all_output:
                return ExploitationResult(
                    success=True,
                    exploitation_type=ExploitationType.DATA_EXFILTRATION,
                    evidence=f"Protected data accessed: {indicator[:50]}...",
                )

        return ExploitationResult(
            success=False,
            exploitation_type=ExploitationType.DATA_EXFILTRATION,
            reason="No protected data markers found",
        )

    def _validate_privilege_escalation(
        self,
        config: ExploitationConfig,
        session: "ChallengeSession",
        executor: Optional["Executor"] = None,
    ) -> ExploitationResult:
        """
        Validate that privileges were escalated.

        Success criteria:
        - uid=0 (root) in output
        - Specific capabilities gained
        - Root-only file accessed
        """
        all_output = self._collect_output(session)

        # Check for root
        if "uid=0" in all_output:
            return ExploitationResult(
                success=True,
                exploitation_type=ExploitationType.PRIVILEGE_ESCALATION,
                evidence="Root access achieved (uid=0)",
            )

        # Check for root indicators
        root_indicators = [
            "uid=0(root)",
            "euid=0",
            "#",  # Root shell prompt (context-dependent)
        ]

        for indicator in root_indicators:
            if indicator in all_output:
                return ExploitationResult(
                    success=True,
                    exploitation_type=ExploitationType.PRIVILEGE_ESCALATION,
                    evidence=f"Privilege escalation indicator: {indicator}",
                )

        # Check success indicators from config
        for indicator in config.success_indicators:
            if indicator in all_output:
                return ExploitationResult(
                    success=True,
                    exploitation_type=ExploitationType.PRIVILEGE_ESCALATION,
                    evidence=f"Privilege indicator found: {indicator}",
                )

        # Optional: Live check via executor
        if executor:
            result = executor.execute_adb("shell id")
            if "uid=0" in result.stdout:
                return ExploitationResult(
                    success=True,
                    exploitation_type=ExploitationType.PRIVILEGE_ESCALATION,
                    evidence="Live check: uid=0 confirmed",
                )

        return ExploitationResult(
            success=False,
            exploitation_type=ExploitationType.PRIVILEGE_ESCALATION,
            reason="No privilege escalation evidence found",
        )

    def _validate_auth_bypass(
        self,
        config: ExploitationConfig,
        session: "ChallengeSession",
    ) -> ExploitationResult:
        """
        Validate that authentication was bypassed.

        Success criteria:
        - Accessed protected activity/content without credentials
        - Bypass indicators in output
        """
        all_output = self._collect_output(session)

        # Check for success indicators
        for indicator in config.success_indicators:
            if indicator.lower() in all_output.lower():
                return ExploitationResult(
                    success=True,
                    exploitation_type=ExploitationType.AUTH_BYPASS,
                    evidence=f"Auth bypass confirmed: {indicator}",
                )

        # Generic bypass indicators
        bypass_indicators = [
            "PostLogin",  # Common activity name after login
            "Dashboard",
            "Welcome",
            "logged in",
            "authenticated",
        ]

        for indicator in bypass_indicators:
            if indicator.lower() in all_output.lower():
                return ExploitationResult(
                    success=True,
                    exploitation_type=ExploitationType.AUTH_BYPASS,
                    evidence=f"Potential auth bypass: {indicator}",
                )

        return ExploitationResult(
            success=False,
            exploitation_type=ExploitationType.AUTH_BYPASS,
            reason="No auth bypass evidence found",
        )

    def _collect_output(self, session: "ChallengeSession") -> str:
        """Collect all output from session attempts."""
        outputs = []

        for attempt in session.attempts:
            # Model output
            if attempt.model_output:
                outputs.append(attempt.model_output)

            # Execution output
            if attempt.execution_result:
                if attempt.execution_result.stdout:
                    outputs.append(attempt.execution_result.stdout)
                if attempt.execution_result.stderr:
                    outputs.append(attempt.execution_result.stderr)

        return "\n".join(outputs)

    def prepare_target(
        self,
        challenge: "Challenge",
        executor: "Executor",
    ) -> bool:
        """
        Prepare the exploitation target before challenge execution.

        This plants flags and sets up the vulnerable environment.

        Args:
            challenge: The challenge to prepare for.
            executor: Executor for running setup commands.

        Returns:
            True if preparation succeeded.
        """
        config = self._get_exploitation_config(challenge)

        if not config.enabled:
            return True

        if config.target_app and config.vulnerability_id:
            return self.target_manager.prepare_target(
                config.target_app,
                config.vulnerability_id,
                executor,
            )

        return True
