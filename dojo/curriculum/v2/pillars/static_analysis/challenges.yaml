challenges:
- id: static_basic_white_001
  name: Identifying Security-Relevant Code Patterns
  version: 2
  type: observation
  pillar: static_analysis
  belt: white
  difficulty: 2
  description: 'Learn to identify security-relevant patterns in Android code.

    Not all patterns are vulnerabilities - just learn to NOTICE them.

    '
  artifacts:
  - type: decompiled_code
    context: Code from a banking app - identify security-relevant sections
    content: "// EDUCATIONAL: Identify which parts are security-relevant\n\npublic class TransferActivity extends Activity\
      \ {\n\n    private SharedPreferences prefs;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState)\
      \ {\n        super.onCreate(savedInstanceState);\n\n        // Section A\n        prefs = getSharedPreferences(\"user_data\"\
      , MODE_PRIVATE);\n        String userId = prefs.getString(\"user_id\", \"\");\n\n        // Section B\n        WebView\
      \ webView = findViewById(R.id.webview);\n        webView.getSettings().setJavaScriptEnabled(true);\n\n        // Section\
      \ C\n        String amount = getIntent().getStringExtra(\"amount\");\n        String recipient = getIntent().getStringExtra(\"\
      recipient\");\n\n        // Section D\n        Log.d(\"Transfer\", \"User \" + userId + \" transferring \" + amount);\n\
      \n        // Section E\n        if (amount != null && recipient != null) {\n            initiateTransfer(userId, recipient,\
      \ amount);\n        }\n    }\n\n    private void initiateTransfer(String user, String to, String amount) {\n       \
      \ // ... transfer logic\n    }\n}\n"
  phases:
  - phase_id: observe
    instruction: 'For each section (A through E), answer:

      1. Is it security-relevant? (Yes/No)

      2. WHY is it relevant (or not)?

      3. What CATEGORY of security concern? (data storage, input, logging, etc.)


      Do NOT say whether it''s vulnerable - just identify relevance.

      '
    expected_output_schema:
      type: object
      properties:
        section_analysis:
          type: array
          items:
            section: string
            is_relevant: boolean
            why: string
            category: string
    evaluation_criteria:
    - name: correct_identification
      weight: 0.4
      description: Correctly identifies relevant sections
    - name: correct_reasoning
      weight: 0.35
      description: Valid reasoning for relevance
    - name: categorization
      weight: 0.25
      description: Proper category assignment
    max_tokens: 1500
  ground_truth:
    key_observations:
    - 'Section A: Yes - data storage, sensitive user data'
    - 'Section B: Yes - WebView with JS, potential attack surface'
    - 'Section C: Yes - input handling, external data source'
    - 'Section D: Yes - logging, may expose sensitive data'
    - 'Section E: Yes - business logic with external inputs'
    - ALL sections are security-relevant in this code
  training:
    common_mistakes:
    - Missing logging as security-relevant
    - Not recognizing Intent extras as external input
    - Jumping to 'vulnerable' instead of 'relevant'
  tags:
  - static_analysis
  - code_review
  - observation
  verification_tasks:
  - instruction: Write an ADB command that lists all installed packages on the device.
    mcp_tool_call:
      tool: adb_shell
      command: pm list packages
    validation_rule:
      type: output_contains
      expected: 'package:'
  - instruction: Identify the hardware manufacturer/vendor of the device.
    mcp_tool_call:
      tool: adb_shell
      command: getprop ro.product.manufacturer
    validation_rule:
      type: regex
      pattern: .+
- id: static_dataflow_yellow_001
  name: Tracing User Input Through Code
  version: 2
  type: observation
  pillar: static_analysis
  belt: yellow
  difficulty: 4
  description: 'Security analysis requires tracing data from SOURCE to SINK.

    Source = where untrusted data enters

    Sink = where data causes action (database, network, display, etc.)

    '
  artifacts:
  - type: decompiled_code
    context: Trace data flow through this code
    content: "// EDUCATIONAL: Data flow tracing exercise\n\npublic class SearchHandler {\n\n    public void handleSearch(Intent\
      \ intent) {\n        // SOURCE: External Intent\n        String rawQuery = intent.getStringExtra(\"query\");\n\n   \
      \     // Transformation 1\n        String trimmed = rawQuery.trim();\n\n        // Transformation 2\n        String\
      \ normalized = trimmed.toLowerCase();\n\n        // Branch 1\n        if (normalized.length() > 100) {\n           \
      \ normalized = normalized.substring(0, 100);\n        }\n\n        // Store for later\n        this.lastQuery = normalized;\n\
      \n        // Branch 2: Display\n        searchView.setText(normalized);  // SINK 1\n\n        // Branch 3: Database\n\
      \        performDatabaseSearch(normalized);  // SINK 2\n    }\n\n    private void performDatabaseSearch(String term)\
      \ {\n        // SINK 2 implementation\n        String query = \"SELECT * FROM products WHERE name LIKE '%\" + term +\
      \ \"%'\";\n        database.rawQuery(query, null);\n    }\n}\n"
  phases:
  - phase_id: observe
    instruction: 'Trace the data flow:


      1. Identify the SOURCE (where untrusted data enters)

      2. Identify all TRANSFORMATIONS (what happens to the data)

      3. Identify all SINKS (where data causes action)

      4. For each sink, does the data reach it TAINTED or SANITIZED?

      '
    expected_output_schema:
      type: object
      properties:
        source:
          location: string
          data_type: string
          trust_level: string
        transformations:
          type: array
          items:
            location: string
            operation: string
            security_effect: string
        sinks:
          type: array
          items:
            location: string
            sink_type: string
            data_state: string
            risk_assessment: string
    evaluation_criteria:
    - name: source_identification
      weight: 0.2
      description: Correctly identifies source
    - name: transformation_tracking
      weight: 0.3
      description: Tracks all transformations
    - name: sink_identification
      weight: 0.3
      description: Identifies all sinks
    - name: taint_assessment
      weight: 0.2
      description: Correct taint state at sinks
    max_tokens: 2000
  ground_truth:
    root_cause: "DATA FLOW ANALYSIS:\n\nSOURCE:\n- Location: intent.getStringExtra(\"query\")\n- Type: String from external\
      \ Intent\n- Trust: UNTRUSTED (external app can send anything)\n\nTRANSFORMATIONS:\n1. trim() - removes whitespace, NO\
      \ security effect\n2. toLowerCase() - case normalization, NO security effect\n3. substring(0,100) - length limit, PARTIAL\
      \ defense (DoS only)\n\nNone of these sanitize SQL special characters!\n\nSINKS:\n1. searchView.setText(normalized)\n\
      \   - Type: UI display\n   - Data state: Still tainted but UI display is generally safe\n   - Risk: Low (Android TextView\
      \ escapes by default)\n\n2. database.rawQuery(...)\n   - Type: SQL execution\n   - Data state: TAINTED - reaches SQL\
      \ string concatenation\n   - Risk: HIGH - SQL injection possible\n\nKEY INSIGHT:\nData flows from untrusted source to\
      \ SQL sink without sanitization.\nThe transformations (trim, toLowerCase, substring) are NOT security controls.\n"
  training:
    common_mistakes:
    - Thinking trim() provides security
    - Missing the UI sink
    - Not recognizing rawQuery as dangerous sink
  tags:
  - data_flow
  - static_analysis
  - source_sink
  cwe_tags:
  - CWE-89
  verification_tasks:
  - instruction: Write an ADB command that captures logcat output filtered to show
    mcp_tool_call:
      tool: adb_shell
      command: logcat -d ActivityManager:E *:S
    validation_rule:
      type: regex
      pattern: .+
  - instruction: Write an ADB command that sends a broadcast intent to trigger
    mcp_tool_call:
      tool: adb_shell
      command: am broadcast -a android.net.conn.CONNECTIVITY_CHANGE
    validation_rule:
      type: output_contains
      expected: Broadcast completed
- id: static_crossfunc_orange_001
  name: Multi-Function Vulnerability Analysis
  version: 2
  type: hypothesis
  pillar: static_analysis
  belt: orange
  difficulty: 5
  description: 'Real vulnerabilities often span multiple functions.

    Practice connecting code across function boundaries.

    '
  artifacts:
  - type: decompiled_code
    context: Multiple interconnected functions
    content: "// EDUCATIONAL: Cross-function analysis exercise\n\npublic class UserManager {\n\n    // Function A: Public\
      \ entry point\n    public void processUserRequest(String action, String data) {\n        if (\"update_profile\".equals(action))\
      \ {\n            updateProfile(data);\n        } else if (\"delete_account\".equals(action)) {\n            deleteAccount(data);\n\
      \        }\n    }\n\n    // Function B: Profile update\n    private void updateProfile(String profileJson) {\n     \
      \   JSONObject profile = new JSONObject(profileJson);\n        String name = profile.getString(\"name\");\n        String\
      \ bio = profile.getString(\"bio\");\n\n        // Validate name\n        if (name.length() > 50) {\n            throw\
      \ new ValidationException(\"Name too long\");\n        }\n\n        // Store in database\n        saveProfile(name,\
      \ bio);\n    }\n\n    // Function C: Database save\n    private void saveProfile(String name, String bio) {\n      \
      \  String insertSql = \"INSERT INTO profiles (name, bio) VALUES ('\"\n            + name + \"', '\" + bio + \"')\";\n\
      \        database.execSQL(insertSql);\n    }\n\n    // Function D: Account deletion\n    private void deleteAccount(String\
      \ userId) {\n        // Only admin can delete\n        if (isCurrentUserAdmin()) {\n            String deleteSql = \"\
      DELETE FROM users WHERE id = ?\";\n            database.execSQL(deleteSql, new Object[]{userId});\n        }\n    }\n\
      }\n"
  phases:
  - phase_id: hypothesize
    instruction: 'Analyze the code flow across functions:


      1. What entry points exist?

      2. Trace data flow through each path

      3. Where is validation present? Where is it missing?

      4. Form hypotheses about vulnerabilities

      5. Note which paths are secure and why

      '
    expected_output_schema:
      type: object
      properties:
        entry_points:
          type: array
          items: string
        data_paths:
          type: array
          items:
            path: string
            validation_points: array
            gaps: array
        hypotheses:
          type: array
          items:
            statement: string
            affected_path: string
            confidence: float
            cwe: string
        secure_paths:
          type: array
          items:
            path: string
            why_secure: string
    evaluation_criteria:
    - name: path_identification
      weight: 0.25
      description: Identifies all code paths
    - name: validation_analysis
      weight: 0.25
      description: Finds validation gaps
    - name: hypothesis_quality
      weight: 0.3
      description: Valid, specific hypotheses
    - name: secure_recognition
      weight: 0.2
      description: Recognizes secure code
    max_tokens: 2500
  ground_truth:
    root_cause: "CROSS-FUNCTION ANALYSIS:\n\nENTRY POINT: processUserRequest(action, data)\n- action: controls which path\n\
      - data: user-controlled payload\n\nPATH 1: update_profile → updateProfile → saveProfile\n- Validation: name length checked\
      \ (<=50)\n- Gap: bio NOT validated at all\n- Gap: Neither name nor bio sanitized for SQL\n- VULNERABLE: SQL injection\
      \ via name OR bio field\n\nPATH 2: delete_account → deleteAccount\n- Validation: Admin check (isCurrentUserAdmin)\n\
      - Database: Uses parameterized query (?)\n- SECURE: Authorization check + parameterized query\n\nHYPOTHESES:\n\nH1:\
      \ SQL injection via bio field in profile update\n- Path: processUserRequest → updateProfile → saveProfile\n- bio is\
      \ extracted from JSON but never validated or sanitized\n- Confidence: 0.9\n- CWE: CWE-89\n\nH2: SQL injection via name\
      \ field despite length check\n- Path: Same as above\n- Length check (50 chars) doesn't prevent injection\n- Attacker\
      \ can inject within 50 chars\n- Confidence: 0.85\n- CWE: CWE-89\n\nSECURE PATTERNS NOTED:\n- deleteAccount uses parameterized\
      \ queries (good!)\n- deleteAccount has authorization check (good!)\n- This shows the developers KNOW how to write secure\
      \ code\n  but didn't apply it consistently\n"
    key_observations:
    - Same codebase has secure and insecure patterns
    - Validation (length) is not the same as sanitization
    - Cross-function analysis reveals inconsistency
  training:
    common_mistakes:
    - Only analyzing single function
    - Thinking length validation prevents injection
    - Missing that bio has NO validation
  tags:
  - cross_function
  - static_analysis
  - sql_injection
  cwe_tags:
  - CWE-89
  verification_tasks:
  - instruction: Write an ADB command that queries the contacts database to show
    mcp_tool_call:
      tool: adb_shell
      command: sqlite3 /data/data/com.android.providers.contacts/databases/contacts2.db '.tables'
    validation_rule:
      type: output_contains
      expected: table
  - instruction: Write an ADB command that queries the Settings content provider
    mcp_tool_call:
      tool: adb_shell
      command: content query --uri content://settings/system
    validation_rule:
      type: output_contains
      expected: 'Row:'
- id: static_component_green_001
  name: Android Component Interaction Analysis
  version: 2
  type: hypothesis
  pillar: static_analysis
  belt: green
  difficulty: 6
  description: 'Android apps have multiple components (Activities, Services, Providers).

    Analyze how they interact and where trust boundaries exist.

    '
  artifacts:
  - type: manifest
    context: AndroidManifest.xml
    content: "<manifest package=\"com.example.vault\">\n    <application>\n        <activity android:name=\".MainActivity\"\
      \ android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\"\
      \ />\n            </intent-filter>\n        </activity>\n\n        <activity android:name=\".UnlockActivity\" android:exported=\"\
      false\" />\n\n        <service android:name=\".VaultService\" android:exported=\"false\" />\n\n        <provider\n \
      \           android:name=\".VaultProvider\"\n            android:authorities=\"com.example.vault.data\"\n          \
      \  android:exported=\"true\"\n            android:readPermission=\"com.example.vault.READ\" />\n\n        <receiver\
      \ android:name=\".BackupReceiver\" android:exported=\"true\">\n            <intent-filter>\n                <action\
      \ android:name=\"com.example.vault.BACKUP\" />\n            </intent-filter>\n        </receiver>\n    </application>\n\
      </manifest>\n"
  - type: decompiled_code
    context: Key component implementations
    content: "// EDUCATIONAL: Component interaction analysis\n\n// MainActivity - the launcher\npublic class MainActivity\
      \ extends Activity {\n    protected void onCreate(Bundle b) {\n        if (isUnlocked()) {\n            showVaultContents();\n\
      \        } else {\n            startActivity(new Intent(this, UnlockActivity.class));\n        }\n    }\n}\n\n// VaultProvider\
      \ - data access\npublic class VaultProvider extends ContentProvider {\n    public Cursor query(Uri uri, ...) {\n   \
      \     // Returns vault data\n        return database.query(\"vault_items\", ...);\n    }\n}\n\n// BackupReceiver - handles\
      \ backup requests\npublic class BackupReceiver extends BroadcastReceiver {\n    public void onReceive(Context ctx, Intent\
      \ intent) {\n        String destination = intent.getStringExtra(\"backup_path\");\n        if (destination != null)\
      \ {\n            performBackup(destination);\n        }\n    }\n\n    private void performBackup(String path) {\n  \
      \      // Copies vault database to specified path\n        File src = ctx.getDatabasePath(\"vault.db\");\n        File\
      \ dst = new File(path);\n        copyFile(src, dst);\n    }\n}\n"
  phases:
  - phase_id: analyze
    instruction: 'Analyze the component architecture:


      1. Map all exported vs non-exported components

      2. Identify trust boundaries

      3. For each exported component, what can external apps do?

      4. Are there paths to bypass non-exported protections?

      5. Form security hypotheses

      '
    expected_output_schema:
      type: object
      properties:
        component_map:
          type: array
          items:
            component: string
            type: string
            exported: boolean
            protection: string
        trust_boundaries:
          type: array
          items: string
        attack_surface:
          type: array
          items:
            component: string
            external_capability: string
        bypass_paths:
          type: array
          items:
            description: string
            mechanism: string
        hypotheses:
          type: array
          items:
            statement: string
            confidence: float
            cwe: string
    evaluation_criteria:
    - name: component_mapping
      weight: 0.25
      description: Correct component analysis
    - name: trust_analysis
      weight: 0.25
      description: Identifies trust boundaries
    - name: attack_surface
      weight: 0.25
      description: Maps external capabilities
    - name: hypothesis_quality
      weight: 0.25
      description: Valid security hypotheses
    max_tokens: 2500
  ground_truth:
    root_cause: 'COMPONENT ANALYSIS:


      EXPORTED COMPONENTS (Attack Surface):

      1. MainActivity - exported (launcher), reasonable

      2. VaultProvider - exported with READ permission, controllable

      3. BackupReceiver - exported with NO permission, DANGEROUS


      NON-EXPORTED (Protected):

      1. UnlockActivity - correctly protected

      2. VaultService - correctly protected


      TRUST BOUNDARIES:

      - App boundary: MainActivity requires unlock before showing data

      - Provider boundary: Requires READ permission

      - Receiver boundary: NO BOUNDARY - anyone can send


      CRITICAL FINDING - BackupReceiver:

      - Exported with no permission

      - Accepts backup_path from Intent

      - Copies vault database to attacker-specified location


      ATTACK SCENARIO:

      1. Attacker app broadcasts: com.example.vault.BACKUP

      2. Intent extra: backup_path="/sdcard/attacker/vault.db"

      3. BackupReceiver copies entire vault database

      4. Attacker reads copied database


      This BYPASSES all other security:

      - Doesn''t need to unlock (UnlockActivity bypass)

      - Doesn''t need READ permission (VaultProvider bypass)

      - Gets ENTIRE database, not just query results


      HYPOTHESES:


      H1: Vault data theft via BackupReceiver

      - Mechanism: Broadcast with controlled backup_path

      - Confidence: 0.95

      - CWE: CWE-926 + CWE-22 (path traversal potential)


      H2: Path traversal in backup destination

      - Mechanism: backup_path="../../../sensitive/location"

      - Confidence: 0.70

      - CWE: CWE-22

      '
    key_observations:
    - Exported receiver with no permission is extremely dangerous
    - One weak component can bypass all other security
    - The unlock flow is meaningless if data can be extracted directly
  training:
    common_mistakes:
    - Only analyzing Activities
    - Missing the BackupReceiver danger
    - Not considering broadcast-based attacks
  tags:
  - component_analysis
  - static_analysis
  - android_security
  cwe_tags:
  - CWE-926
  - CWE-22
  verification_tasks:
  - instruction: Write an ADB command that sets up port forwarding from
    mcp_tool_call:
      tool: adb_forward
      host_port: '8080'
      device_port: '8080'
    validation_rule:
      type: regex
      pattern: .+
  - instruction: Write an ADB command that creates a backup of the Settings
    mcp_tool_call:
      tool: adb_backup
      package: com.android.settings
      output_file: settings_backup.ab
    validation_rule:
      type: regex
      pattern: .+
- id: static_crypto_blue_001
  name: Cryptographic Implementation Review
  version: 2
  type: hypothesis
  pillar: static_analysis
  belt: blue
  difficulty: 7
  description: 'Cryptographic code is easy to get wrong. Learn to identify

    common crypto mistakes through static analysis.

    '
  artifacts:
  - type: decompiled_code
    context: Encryption utility class
    content: "// EDUCATIONAL: Crypto review exercise - find the issues\n\npublic class SecureStorage {\n\n    private static\
      \ final String KEY = \"MySecretKey12345\";  // 16 bytes\n\n    public String encrypt(String plaintext) {\n        try\
      \ {\n            SecretKeySpec keySpec = new SecretKeySpec(KEY.getBytes(), \"AES\");\n            Cipher cipher = Cipher.getInstance(\"\
      AES/ECB/PKCS5Padding\");\n            cipher.init(Cipher.ENCRYPT_MODE, keySpec);\n            byte[] encrypted = cipher.doFinal(plaintext.getBytes());\n\
      \            return Base64.encodeToString(encrypted, Base64.DEFAULT);\n        } catch (Exception e) {\n           \
      \ return null;\n        }\n    }\n\n    public String decrypt(String ciphertext) {\n        try {\n            SecretKeySpec\
      \ keySpec = new SecretKeySpec(KEY.getBytes(), \"AES\");\n            Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\"\
      );\n            cipher.init(Cipher.DECRYPT_MODE, keySpec);\n            byte[] decrypted = cipher.doFinal(Base64.decode(ciphertext,\
      \ Base64.DEFAULT));\n            return new String(decrypted);\n        } catch (Exception e) {\n            return\
      \ null;\n        }\n    }\n\n    public String hashPassword(String password) {\n        try {\n            MessageDigest\
      \ md = MessageDigest.getInstance(\"MD5\");\n            byte[] hash = md.digest(password.getBytes());\n            return\
      \ bytesToHex(hash);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    private String\
      \ bytesToHex(byte[] bytes) {\n        StringBuilder sb = new StringBuilder();\n        for (byte b : bytes) {\n    \
      \        sb.append(String.format(\"%02x\", b));\n        }\n        return sb.toString();\n    }\n}\n"
  phases:
  - phase_id: analyze
    instruction: 'Review this cryptographic code for vulnerabilities:


      1. List all cryptographic operations

      2. For each, identify what''s wrong (if anything)

      3. Explain WHY it''s a problem

      4. What''s the correct implementation?

      5. Rank severity of each issue

      '
    expected_output_schema:
      type: object
      properties:
        crypto_operations:
          type: array
          items:
            operation: string
            issues:
              type: array
              items:
                issue: string
                why_bad: string
                severity: string
                correct_approach: string
        overall_assessment: string
    evaluation_criteria:
    - name: issue_identification
      weight: 0.35
      description: Finds all crypto issues
    - name: explanation_quality
      weight: 0.3
      description: Explains why each is bad
    - name: fix_knowledge
      weight: 0.2
      description: Knows correct approach
    - name: severity_ranking
      weight: 0.15
      description: Appropriate severity
    max_tokens: 2500
  ground_truth:
    root_cause: "CRYPTOGRAPHIC ISSUES FOUND:\n\nISSUE 1: Hardcoded encryption key\n- Location: KEY = \"MySecretKey12345\"\n\
      - Why bad: Key visible in decompiled code, same for all users\n- Severity: CRITICAL\n- Fix: Derive key from user password\
      \ with PBKDF2, or use Android Keystore\n\nISSUE 2: ECB mode for AES\n- Location: \"AES/ECB/PKCS5Padding\"\n- Why bad:\
      \ ECB encrypts identical blocks to identical ciphertext\n  (famous \"ECB penguin\" problem), allows pattern analysis\n\
      - Severity: HIGH\n- Fix: Use AES/GCM/NoPadding or AES/CBC/PKCS5Padding with random IV\n\nISSUE 3: No IV (Initialization\
      \ Vector)\n- Location: cipher.init without IV\n- Why bad: Even with CBC, same plaintext always produces same\n  ciphertext.\
      \ Makes encryption deterministic.\n- Severity: HIGH\n- Fix: Generate random IV, prepend to ciphertext\n\nISSUE 4: MD5\
      \ for password hashing\n- Location: MessageDigest.getInstance(\"MD5\")\n- Why bad: MD5 is broken, fast to brute force,\
      \ no salt\n- Severity: CRITICAL\n- Fix: Use bcrypt, scrypt, or Argon2 with salt\n\nISSUE 5: No salt for password hash\n\
      - Location: md.digest(password.getBytes())\n- Why bad: Same password always produces same hash,\n  vulnerable to rainbow\
      \ tables\n- Severity: HIGH\n- Fix: Generate random salt per user, hash(salt + password)\n\nISSUE 6: Silent exception\
      \ handling\n- Location: catch (Exception e) { return null; }\n- Why bad: Crypto failures should be loud, not silent\n\
      - Severity: MEDIUM\n- Fix: Throw or log, never silently fail\n\nOVERALL: This is \"cargo cult cryptography\" - using\
      \ crypto APIs\nwithout understanding the requirements. Every aspect is wrong.\n"
    key_observations:
    - Hardcoded key defeats the purpose of encryption
    - ECB mode is almost never appropriate
    - MD5 hasn't been acceptable for passwords since ~2010
  training:
    common_mistakes:
    - Thinking 'uses AES' means secure
    - Missing the ECB issue
    - Not knowing why MD5 is bad
  tags:
  - cryptography
  - static_analysis
  - code_review
  cwe_tags:
  - CWE-798
  - CWE-327
  - CWE-328
  - CWE-916
  verification_tasks:
  - instruction: Write an ADB command that sets up port forwarding from
    mcp_tool_call:
      tool: adb_forward
      host_port: '8080'
      device_port: '8080'
    validation_rule:
      type: regex
      pattern: .+
  - instruction: Write an ADB command that creates a backup of the Settings
    mcp_tool_call:
      tool: adb_backup
      package: com.android.settings
      output_file: settings_backup.ab
    validation_rule:
      type: regex
      pattern: .+
