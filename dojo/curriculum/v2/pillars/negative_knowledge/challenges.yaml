challenges:
- id: neg_secure_white_001
  name: Secure Password Storage
  version: 2
  type: negative
  pillar: negative_knowledge
  belt: white
  difficulty: 2
  description: 'Analyze this password storage implementation.

    Determine if it is vulnerable or secure, and explain your reasoning.

    '
  artifacts:
  - type: decompiled_code
    context: SecureCredentialManager from a banking app
    content: "public class SecureCredentialManager {\n    private static final int ITERATIONS = 100000;\n    private static\
      \ final int KEY_LENGTH = 256;\n\n    public String hashPassword(String password) {\n        byte[] salt = new byte[16];\n\
      \        new SecureRandom().nextBytes(salt);\n\n        PBEKeySpec spec = new PBEKeySpec(\n            password.toCharArray(),\n\
      \            salt,\n            ITERATIONS,\n            KEY_LENGTH\n        );\n\n        SecretKeyFactory factory\
      \ = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA256\");\n        byte[] hash = factory.generateSecret(spec).getEncoded();\n\
      \n        // Store salt:hash together\n        return Base64.encodeToString(salt, Base64.NO_WRAP) + \":\" +\n      \
      \         Base64.encodeToString(hash, Base64.NO_WRAP);\n    }\n\n    public boolean verifyPassword(String password,\
      \ String stored) {\n        String[] parts = stored.split(\":\");\n        byte[] salt = Base64.decode(parts[0], Base64.NO_WRAP);\n\
      \        byte[] storedHash = Base64.decode(parts[1], Base64.NO_WRAP);\n\n        PBEKeySpec spec = new PBEKeySpec(\n\
      \            password.toCharArray(),\n            salt,\n            ITERATIONS,\n            KEY_LENGTH\n        );\n\
      \n        SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA256\");\n        byte[] testHash\
      \ = factory.generateSecret(spec).getEncoded();\n\n        return MessageDigest.isEqual(storedHash, testHash);\n    }\n\
      }\n"
  phases:
  - phase_id: observe
    instruction: 'Analyze this password handling code.

      For each security-relevant pattern you observe, determine:

      1. What the pattern is

      2. Whether it strengthens or weakens security

      3. Why

      '
    expected_output_schema:
      type: object
      properties:
        is_vulnerable: boolean
        confidence: number
        security_properties:
          type: array
          items:
            property: string
            status: string
            reasoning: string
        attempted_attacks:
          type: array
          items:
            attack: string
            result: string
            why: string
    evaluation_criteria:
    - name: correct_classification
      weight: 0.4
      description: Correctly identifies as NOT vulnerable
    - name: security_property_id
      weight: 0.3
      description: Identifies what makes it secure
    - name: attack_resistance
      weight: 0.2
      description: Explains why attacks fail
    - name: no_false_positives
      weight: 0.1
      description: Doesn't claim vulnerabilities that don't exist
    max_tokens: 1500
  ground_truth:
    vulnerability_present: false
    vulnerability_type: null
    cwe_id: null
    secure_properties:
    - PBKDF2 with SHA256 - modern, NIST-approved key derivation
    - 100,000 iterations - meets current recommendations
    - Random 16-byte salt per password - prevents rainbow tables
    - 256-bit key length - computationally secure
    - SecureRandom for salt - cryptographically secure randomness
    - MessageDigest.isEqual for comparison - timing-attack resistant
    key_observations:
    - Uses PBKDF2 not MD5/SHA1
    - Salt is random and per-password
    - High iteration count
    - Constant-time comparison
  training:
    reasoning_chain_required: true
    dpo_pairs_available: true
    negative_examples:
    - Claiming PBKDF2 is weak (it's not)
    - Claiming Base64 is encryption (it's encoding for storage)
    - Claiming any vulnerability exists
    common_mistakes:
    - Confusing encoding (Base64) with encryption
    - Not recognizing constant-time comparison
    - False positive on iteration count
    pattern_family: secure_password_storage
  tags:
  - crypto
  - password
  - pbkdf2
  - secure
  cwe_tags: []
  owasp_tags: []
  verification_tasks:
  - instruction: Determine the Security Patch Level (SPL) of the device.
    mcp_tool_call:
      tool: adb_shell
      command: getprop ro.build.version.security_patch
    validation_rule:
      type: regex
      pattern: ^\d{4}-\d{2}-\d{2}
- id: neg_secure_white_002
  name: Secure WebView Configuration
  version: 2
  type: negative
  pillar: negative_knowledge
  belt: white
  difficulty: 3
  description: 'Review this WebView implementation for security issues.

    Determine if the configuration is secure or vulnerable.

    '
  artifacts:
  - type: decompiled_code
    context: SecureWebViewActivity for displaying help content
    content: "public class SecureWebViewActivity extends Activity {\n    private WebView webView;\n    private static final\
      \ Set<String> ALLOWED_HOSTS = new HashSet<>(Arrays.asList(\n        \"help.myapp.com\",\n        \"docs.myapp.com\"\n\
      \    ));\n\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\
      \        webView = new WebView(this);\n        setContentView(webView);\n\n        WebSettings settings = webView.getSettings();\n\
      \        settings.setJavaScriptEnabled(true);\n        settings.setAllowFileAccess(false);\n        settings.setAllowContentAccess(false);\n\
      \        settings.setAllowFileAccessFromFileURLs(false);\n        settings.setAllowUniversalAccessFromFileURLs(false);\n\
      \n        webView.setWebViewClient(new WebViewClient() {\n            public boolean shouldOverrideUrlLoading(WebView\
      \ view, WebResourceRequest request) {\n                Uri uri = request.getUrl();\n\n                if (!\"https\"\
      .equals(uri.getScheme())) {\n                    return true; // Block non-HTTPS\n                }\n\n            \
      \    if (!ALLOWED_HOSTS.contains(uri.getHost())) {\n                    // Open external links in browser\n        \
      \            Intent intent = new Intent(Intent.ACTION_VIEW, uri);\n                    startActivity(intent);\n    \
      \                return true;\n                }\n\n                return false; // Allow loading in WebView\n    \
      \        }\n        });\n\n        // Load from trusted source only\n        webView.loadUrl(\"https://help.myapp.com/\"\
      );\n    }\n}\n"
  - type: manifest
    context: Activity declaration
    content: "<activity\n    android:name=\".SecureWebViewActivity\"\n    android:exported=\"false\" />\n"
  phases:
  - phase_id: observe
    instruction: 'Analyze this WebView configuration.

      Identify all security controls and assess their effectiveness.

      Determine if this implementation is vulnerable to common WebView attacks.

      '
    expected_output_schema:
      type: object
      properties:
        is_vulnerable: boolean
        confidence: number
        security_properties:
          type: array
        attempted_attacks:
          type: array
    evaluation_criteria:
    - name: correct_classification
      weight: 0.4
      description: Correctly identifies as secure
    - name: security_property_id
      weight: 0.3
      description: Identifies security controls
    - name: attack_resistance
      weight: 0.2
      description: Explains defense against attacks
    - name: no_false_positives
      weight: 0.1
      description: Doesn't hallucinate vulnerabilities
    max_tokens: 1500
  ground_truth:
    vulnerability_present: false
    secure_properties:
    - exported=false - not accessible from other apps
    - HTTPS-only enforcement via URL scheme check
    - Host allowlist with strict matching
    - File access disabled (setAllowFileAccess(false))
    - Content access disabled
    - Cross-origin file access blocked
    - No JavaScript interface exposed
    - External links opened in browser, not WebView
    key_observations:
    - Activity not exported - no external attack surface
    - URL validation before loading
    - Allowlist approach (safer than blocklist)
    - All dangerous WebSettings disabled
  training:
    negative_examples:
    - Claiming JavaScript enabled is a vulnerability (it's not without exposed interfaces)
    - Claiming any URL can be loaded (allowlist prevents this)
    common_mistakes:
    - False positive on JavaScript being enabled
    - Not recognizing the layered defense
    pattern_family: secure_webview
  tags:
  - webview
  - secure_config
  - allowlist
  verification_tasks:
  - instruction: Write an ADB command that lists all running processes on the device.
    mcp_tool_call:
      tool: adb_shell
      command: ps
    validation_rule:
      type: output_contains
      expected: PID
- id: neg_compare_yellow_001
  name: SQL Query Comparison
  version: 2
  type: negative
  pillar: negative_knowledge
  belt: yellow
  difficulty: 4
  description: 'Compare these two SQL query implementations.

    Identify which is secure, which is vulnerable, and explain why.

    '
  artifacts:
  - type: decompiled_code
    context: Two different query implementations from same app
    content: "// Implementation A - UserRepository.java\npublic class UserRepositoryA {\n    public User findByUsername(String\
      \ username) {\n        String query = \"SELECT * FROM users WHERE username = '\" + username + \"'\";\n        return\
      \ db.rawQuery(query, null);\n    }\n}\n\n// Implementation B - UserRepository.java (refactored)\npublic class UserRepositoryB\
      \ {\n    public User findByUsername(String username) {\n        String query = \"SELECT * FROM users WHERE username\
      \ = ?\";\n        return db.rawQuery(query, new String[]{username});\n    }\n}\n"
  phases:
  - phase_id: observe
    instruction: 'Compare both implementations.

      For each:

      1. Determine if it''s vulnerable or secure

      2. Explain the specific mechanism that makes it so

      3. Show how an attack would succeed or fail

      '
    expected_output_schema:
      type: object
      properties:
        implementation_a:
          is_vulnerable: boolean
          vulnerability_type: string
          attack_example: string
        implementation_b:
          is_vulnerable: boolean
          security_mechanism: string
          why_attack_fails: string
        key_difference: string
    evaluation_criteria:
    - name: correct_classification
      weight: 0.3
      description: Correctly identifies A=vulnerable, B=secure
    - name: mechanism_explanation
      weight: 0.3
      description: Explains parameterization defense
    - name: attack_demonstration
      weight: 0.25
      description: Shows valid attack for A, explains failure for B
    - name: no_errors
      weight: 0.15
      description: No factual errors
    max_tokens: 1500
  ground_truth:
    vulnerability_present: true
    key_observations:
    - A uses string concatenation - VULNERABLE to SQL injection
    - B uses parameterized query with ? placeholder - SECURE
    - The difference is how user input is incorporated into query
    secure_properties:
    - Parameterized queries separate code from data
    - Database treats parameter as literal value, not SQL code
    - Special characters in input are automatically escaped
  training:
    common_mistakes:
    - Not recognizing ? placeholder as parameterization
    - Claiming both are vulnerable
    - Claiming both are secure
    pattern_family: sql_injection_comparison
  tags:
  - sql
  - parameterized_query
  - comparison
  cwe_tags:
  - CWE-89
  verification_tasks:
  - instruction: Write an ADB command that displays the network interface
    mcp_tool_call:
      tool: adb_shell
      command: ip addr
    validation_rule:
      type: regex
      pattern: \d+\.\d+\.\d+\.\d+
  - instruction: Write an ADB command that lists all currently running services
    mcp_tool_call:
      tool: adb_shell
      command: dumpsys activity services
    validation_rule:
      type: output_contains
      expected: ServiceRecord
- id: neg_subtle_orange_001
  name: Secure Intent Handling
  version: 2
  type: negative
  pillar: negative_knowledge
  belt: orange
  difficulty: 5
  description: 'Analyze this deep link handler. Despite being exported, it implements

    several security controls. Determine if it''s still vulnerable.

    '
  artifacts:
  - type: decompiled_code
    context: PaymentDeepLinkHandler - handles payment intents
    content: "public class PaymentDeepLinkHandler extends Activity {\n\n    protected void onCreate(Bundle savedInstanceState)\
      \ {\n        super.onCreate(savedInstanceState);\n\n        // Verify calling package\n        String callingPackage\
      \ = getCallingPackage();\n        if (callingPackage == null) {\n            // Started via deep link, not startActivityForResult\n\
      \            // Require user authentication\n            if (!isUserAuthenticated()) {\n                redirectToLogin();\n\
      \                return;\n            }\n        } else if (!isAllowedCaller(callingPackage)) {\n            finish();\n\
      \            return;\n        }\n\n        Uri data = getIntent().getData();\n        if (data == null || !\"https\"\
      .equals(data.getScheme())) {\n            finish();\n            return;\n        }\n\n        // Validate signature\
      \ parameter\n        String amount = data.getQueryParameter(\"amount\");\n        String recipient = data.getQueryParameter(\"\
      recipient\");\n        String timestamp = data.getQueryParameter(\"timestamp\");\n        String signature = data.getQueryParameter(\"\
      signature\");\n\n        if (!verifySignature(amount, recipient, timestamp, signature)) {\n            showError(\"\
      Invalid request signature\");\n            finish();\n            return;\n        }\n\n        // Check timestamp freshness\
      \ (5 minute window)\n        long ts = Long.parseLong(timestamp);\n        if (Math.abs(System.currentTimeMillis() -\
      \ ts) > 300000) {\n            showError(\"Request expired\");\n            finish();\n            return;\n       \
      \ }\n\n        // Show confirmation dialog\n        showPaymentConfirmation(amount, recipient);\n    }\n\n    private\
      \ boolean verifySignature(String amount, String recipient,\n                                    String timestamp, String\
      \ signature) {\n        String data = amount + \"|\" + recipient + \"|\" + timestamp;\n        try {\n            PublicKey\
      \ key = getServerPublicKey();\n            Signature sig = Signature.getInstance(\"SHA256withRSA\");\n            sig.initVerify(key);\n\
      \            sig.update(data.getBytes());\n            return sig.verify(Base64.decode(signature, Base64.NO_WRAP));\n\
      \        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    private boolean isAllowedCaller(String\
      \ packageName) {\n        // Only allow calls from our own apps\n        return packageName.startsWith(\"com.ourcompany.\"\
      );\n    }\n\n    private boolean isUserAuthenticated() {\n        // Check if user has active session with biometric/PIN\n\
      \        return SessionManager.getInstance().isAuthenticated();\n    }\n}\n"
  - type: manifest
    context: Activity declaration
    content: "<activity\n    android:name=\".PaymentDeepLinkHandler\"\n    android:exported=\"true\">\n    <intent-filter>\n\
      \        <action android:name=\"android.intent.action.VIEW\" />\n        <category android:name=\"android.intent.category.DEFAULT\"\
      \ />\n        <category android:name=\"android.intent.category.BROWSABLE\" />\n        <data android:scheme=\"https\"\
      \ android:host=\"pay.ourapp.com\" />\n    </intent-filter>\n</activity>\n"
  phases:
  - phase_id: observe
    instruction: 'This activity is exported and handles payments - a high-value target.

      Analyze ALL security controls implemented.

      Determine if despite being exported, it''s adequately protected.

      '
    expected_output_schema:
      type: object
      properties:
        is_vulnerable: boolean
        confidence: number
        security_controls:
          type: array
          items:
            control: string
            effectiveness: string
            bypass_possible: boolean
        overall_assessment: string
    evaluation_criteria:
    - name: correct_classification
      weight: 0.35
      description: Correctly assesses overall security
    - name: control_identification
      weight: 0.3
      description: Identifies all security controls
    - name: bypass_analysis
      weight: 0.25
      description: Correctly assesses bypass potential
    - name: no_false_positives
      weight: 0.1
      description: Doesn't claim false vulnerabilities
    max_tokens: 2000
  ground_truth:
    vulnerability_present: false
    secure_properties:
    - Caller package verification for startActivityForResult
    - User authentication required for deep link access
    - HTTPS scheme enforcement
    - Cryptographic signature verification on parameters
    - Server's public key for signature (asymmetric - can't forge)
    - Timestamp freshness check (5 min window) prevents replay
    - User confirmation dialog before action
    key_observations:
    - Multiple layers of defense
    - Signature is RSA with server key - attacker can't forge
    - Timestamp prevents replay attacks
    - Even if deep link is triggered, user must confirm
    - Authentication required blocks unauthorized access
  training:
    negative_examples:
    - Claiming exported=true means vulnerable (defense in depth)
    - Claiming signature can be forged (asymmetric crypto)
    - Missing the timestamp replay protection
    common_mistakes:
    - Assuming exported means vulnerable
    - Not understanding RSA signature verification
    - Missing the layered defense approach
    pattern_family: secure_deep_link
  prerequisites:
  - neg_secure_white_002
  tags:
  - deep_link
  - signature
  - authentication
  - layered_defense
  verification_tasks:
  - instruction: Write an ADB command that displays all active network connections
    mcp_tool_call:
      tool: adb_shell
      command: netstat -an
    validation_rule:
      type: output_contains
      expected: LISTEN
  - instruction: Write an ADB command that lists all activities, services, and
    mcp_tool_call:
      tool: adb_shell
      command: dumpsys package com.android.browser | grep -A 100 'Activity Resolver Table'
    validation_rule:
      type: output_contains
      expected: Activity
- id: neg_fp_purple_001
  name: Apparent Vulnerability That Isn't
  version: 2
  type: negative
  pillar: negative_knowledge
  belt: purple
  difficulty: 7
  description: 'This code appears to have a path traversal vulnerability at first glance.

    Analyze carefully to determine if it''s actually exploitable.

    '
  artifacts:
  - type: decompiled_code
    context: FileDownloadService with apparent path traversal
    content: "public class FileDownloadService {\n    private static final String BASE_DIR = \"/data/data/com.app/files/downloads/\"\
      ;\n\n    public File getDownloadedFile(String filename) {\n        // Looks vulnerable - filename directly used!\n \
      \       File requested = new File(BASE_DIR + filename);\n\n        // But wait...\n        String canonicalPath;\n \
      \       try {\n            canonicalPath = requested.getCanonicalPath();\n        } catch (IOException e) {\n      \
      \      throw new SecurityException(\"Invalid file path\");\n        }\n\n        // Verify the canonical path is still\
      \ within allowed directory\n        if (!canonicalPath.startsWith(BASE_DIR)) {\n            throw new SecurityException(\n\
      \                \"Access denied: path escapes download directory\"\n            );\n        }\n\n        if (!requested.exists())\
      \ {\n            throw new FileNotFoundException(\"File not found\");\n        }\n\n        return requested;\n    }\n\
      }\n"
  phases:
  - phase_id: observe
    instruction: 'At first glance, this looks like path traversal (filename directly concatenated).

      Analyze the FULL code flow to determine if it''s actually exploitable.

      Consider what getCanonicalPath() does and how the check works.

      '
    expected_output_schema:
      type: object
      properties:
        initial_impression: string
        actual_vulnerability: boolean
        defense_mechanism: string
        attack_attempts:
          type: array
          items:
            payload: string
            blocked_by: string
            explanation: string
    evaluation_criteria:
    - name: correct_final_assessment
      weight: 0.4
      description: Correctly determines NOT vulnerable
    - name: defense_understanding
      weight: 0.3
      description: Understands canonical path check
    - name: attack_analysis
      weight: 0.2
      description: Shows why attacks fail
    - name: reasoning_quality
      weight: 0.1
      description: Clear reasoning chain
    max_tokens: 1500
  ground_truth:
    vulnerability_present: false
    secure_properties:
    - getCanonicalPath() resolves ../.. sequences
    - startsWith check on CANONICAL path, not raw input
    - Throws SecurityException on escape attempt
    - BASE_DIR constant prevents manipulation
    key_observations:
    - Initial concatenation LOOKS dangerous
    - But canonical path resolution happens BEFORE the check
    - ../../etc/passwd resolves to /etc/passwd
    - /etc/passwd does NOT start with /data/data/com.app/files/downloads/
    - Therefore, attack is blocked
  training:
    negative_examples:
    - Claiming path traversal exists (the canonical check prevents it)
    - Not understanding what getCanonicalPath does
    common_mistakes:
    - Stopping analysis at the concatenation
    - Not following through to see the defense
    - Not understanding canonical path resolution
    pattern_family: path_traversal_defense
    difficulty_factors:
    - Requires understanding Java File canonicalization
    - Initial appearance is deceptive
    - Defense is non-obvious
  tags:
  - path_traversal
  - canonicalization
  - false_positive
  cwe_tags: []
  verification_tasks:
  - instruction: Write an ADB command that lists the contents of the data directory
    mcp_tool_call:
      tool: adb_shell
      command: run-as com.android.settings ls /data/data/com.android.settings/
    validation_rule:
      type: output_contains
      expected: shared_prefs
  - instruction: Write an ADB command that queries the contacts database to show
    mcp_tool_call:
      tool: adb_shell
      command: sqlite3 /data/data/com.android.providers.contacts/databases/contacts2.db '.tables'
    validation_rule:
      type: output_contains
      expected: table
  - instruction: Write an ADB command that displays all active network connections
    mcp_tool_call:
      tool: adb_shell
      command: netstat -an
    validation_rule:
      type: output_contains
      expected: LISTEN
